##### Liste des fichiers inclus : menuQuit.c,declarations.h menu.c,enemy.c level.h,items.h character.h,enum.h display.c,collisions.c menu.h,game.h arduinoReadWrite.c,objects.h bullet.c,functions.c events.c,level.c display.h,items.c bullet.h,main.c functions.h,mouvement.c collision.h


##### ./menuQuit.c #####
#include "game.h"

/**

* @file menuQuit.c

* @author C Squad

* @version 1.0

* @date May 14, 2016

*/

void saving_menu(GAME *game, Dialogue dialogue)
{
	dialogue.btnYes = dialogue.saveYESa;
	dialogue.btnNo = dialogue.saveNOb;

	if (dialogue.interrupt == 1)
	{
		if (dialogue.saving_state == 1)
		{
			dialogue.btnYes = dialogue.saveYESa;
			dialogue.btnNo = dialogue.saveNOb;

		}
		else if (dialogue.saving_state == 2)
		{
			dialogue.btnYes = dialogue.saveYESb;
			dialogue.btnNo = dialogue.saveNOa;
		}

        SDL_BlitSurface(dialogue.dialogue, NULL, game->screen, &dialogue.positionD);
        SDL_BlitSurface(dialogue.btnYes, NULL, game->screen, &dialogue.positionYES);
        SDL_BlitSurface(dialogue.btnNo, NULL, game->screen, &dialogue.positionNO);


	SDL_Flip(game->screen);

	}

}

void load_menuQuit(GAME *game)
{

	game->dialogue.dialogue = IMG_Load("DATA/GFX/GUI/Savingame.png");
	game->dialogue.saveYESa = IMG_Load("DATA/GFX/GUI/yesa.png");
	game->dialogue.saveYESb = IMG_Load("DATA/GFX/GUI/yesb.png");
	game->dialogue.saveNOa = IMG_Load("DATA/GFX/GUI/noa.png");
	game->dialogue.saveNOb = IMG_Load("DATA/GFX/GUI/nob.png");

    game->dialogue.positionD.x = (game->config.resolution_w-game->dialogue.dialogue->w)/2;
	game->dialogue.positionD.y = 101;
	game->dialogue.positionYES.x = 182 + (game->config.resolution_w-game->dialogue.dialogue->w)/2;
	game->dialogue.positionYES.y = 420;
	game->dialogue.positionNO.x = 382+(game->config.resolution_w-game->dialogue.dialogue->w)/2;
	game->dialogue.positionNO.y = 420;

}

int save_level(GAME *game)
{
	FILE *fichier = NULL;
	fichier = fopen("save.bin", "wb");
	if (fichier == NULL)
		return 0;
	else
    {
        fwrite(&game->level, sizeof(int), 1, fichier);
        fclose(fichier);
    }
	return 1;

}

int load_level(GAME *game)
{
	FILE *fichier = NULL;
	fichier = fopen("save.bin", "rb");
	if (fichier == NULL)
		return 0;
	else
    {
        fread(&game->level, sizeof(int), 1, fichier);
        fclose(fichier);
        //loadLevel(game);
        return 1;
    }

}




##### ./declarations.h #####
#ifndef DEC
#define DEC

typedef int bool;
#define true 1
#define false 0

#define PLAT_H 600
#define PLAT_W game->config.resolution_w
#define FPS 50
#define CHAR_H 90//330//160
#define CHAR_W 90//330//80
#define CHAR_BIG_H 170//330//160
#define CHAR_BIG_W 170//330//80
#define SPEED game->character.speed//12//6
#define GRAVITY 9
#define JUMP_POWER 16
#define maxJmpH 95
#define RELOAD 1000
//#define MAX_ITEMS 4

#endif


##### ./menu.c #####
#include "menu.h"
#include "game.h"
#include "level.h"

/**

* @file menu.c

* @brief It never ends menu.

* @author C Squad

* @version 1.2

* @date May 23, 2016

*/

void get_out();
int get_config(GAME *game);

int game_menu(GAME *game)
{
    Menu menu;

    int fix=0;
    Mix_Chunk *son;
    son = Mix_LoadWAV("DATA/SFX/wood.ogg");

    SDL_Surface *animation[11]= {NULL};
    SDL_Surface *titre[56];
    SDL_Surface *boutonsA[5]= {NULL};
    SDL_Surface *boutonsB[5]= {NULL};

    SDL_Surface *exit_menu[5]= {NULL};
    SDL_Surface *options_back=NULL;
    SDL_Surface *options[8]= {NULL};

    SDL_Rect positionfond = {0,0,0,0};
    SDL_Rect positionsrc = {0,20,1167,700};
    SDL_Rect positionbouton[5] = {{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0}};

    SDL_Rect positionexit, positionyes, positionno;
    SDL_Rect positionoptions, positionoption1, positionoption2;

    SDL_Event event;
    int TITLE_SHOWN=0;

    int i=0, v=0, j=0;
    char file_name[256]=" ";

    int fix_son=0;

    Mix_Music *musique;

    /* START Music Stuff */

    Mix_AllocateChannels(2);
    musique = Mix_LoadMUS("DATA/SFX/menu.ogg"); //Chargement de la musique

    Mix_VolumeChunk(son, MIX_MAX_VOLUME/8);
    Mix_VolumeMusic(MIX_MAX_VOLUME/4);
    Mix_PlayMusic(musique, -1);

    /* END Music Stuff */


    //Variable initialization

    menu.done=0;
    menu.etat=1;
    menu.SHOW_OPTION=0;
    menu.SHOW_EXIT=0;
    menu.opt1_select=0;
    menu.opt2_select=0;
    menu.exit_yes=0;
    menu.exit_no=0;

    menu.continue_level=0;


    positionfond.x = 0+100;
    positionfond.y = 0;
    positionbouton[0].x = 495+100;
    positionbouton[0].y = 376;
    positionbouton[1].x = 503+100;
    positionbouton[1].y = 446;
    positionbouton[2].x = 513+100;
    positionbouton[2].y = 511;
    positionbouton[3].x = 546+100;
    positionbouton[3].y = 576;
    positionbouton[4].x = 550+100;
    positionbouton[4].y = 639;

    positionoptions.x = 198+100;
    positionoptions.y = 101;
    positionoption1.x = 290+100;
    positionoption1.y = 226;
    positionoption2.x = 370+100;
    positionoption2.y = 317;


    positionexit.x = 198+100;
    positionexit.y = 200;
    positionyes.x = 432+100;
    positionyes.y = 420;
    positionno.x = 634+100;
    positionno.y = 420;


    for (i = 1; i < 10; i++)
    {
        snprintf(file_name, sizeof(file_name), "DATA/GFX/menu/animation/a%d.png", i);
        animation[i] = IMG_Load(file_name);
    }


//Arriere-plan du menu
    for (i = 1; i < 5; i++)
    {
        snprintf(file_name, sizeof(file_name), "DATA/GFX/menu/animation/a%d.png", i);
        animation[i] = IMG_Load(file_name);
    }

//titre
    for (i = 1; i < 55; i++)
    {
        snprintf(file_name, sizeof(file_name), "DATA/GFX/menu/titre/b00%d.png", i);
        titre[i] = IMG_Load(file_name);
    }

//boutons
    for (i=1; i<6; i++)
    {
        snprintf(file_name, sizeof(file_name), "DATA/GFX/menu/boutons/%da.png", i);
        boutonsA[i] = IMG_Load(file_name);

        snprintf(file_name, sizeof(file_name), "DATA/GFX/menu/boutons/%db.png", i);
        boutonsB[i] = IMG_Load(file_name);
    }

//menu exit

    exit_menu[0]=IMG_Load("DATA/GFX/menu/options/Exit.png");
    exit_menu[1]=IMG_Load("DATA/GFX/menu/options/yesb.png");
    exit_menu[2]=IMG_Load("DATA/GFX/menu/options/yesa.png");
    exit_menu[3]=IMG_Load("DATA/GFX/menu/options/nob.png");
    exit_menu[4]=IMG_Load("DATA/GFX/menu/options/noa.png");


//menu_options
    options_back = IMG_Load("DATA/GFX/menu/options/Options.png");
    options[0] = IMG_Load("DATA/GFX/menu/options/OFFb.png");
    options[1] = IMG_Load("DATA/GFX/menu/options/ONb.png");
    options[2] = IMG_Load("DATA/GFX/menu/options/OFFa.png");
    options[3] = IMG_Load("DATA/GFX/menu/options/ONa.png");
    options[4] = IMG_Load("DATA/GFX/menu/options/MUSICONa.png");
    options[5] = IMG_Load("DATA/GFX/menu/options/MUSICOFFa.png");
    options[6] = IMG_Load("DATA/GFX/menu/options/MUSICONb.png");
    options[7] = IMG_Load("DATA/GFX/menu/options/MUSICOFFb.png");


    menu.etat=1;

    i=0;
    v=0;

    menu.continuer=1;
    menu.fullscreenfix=1;

    while (menu.continuer)
    {

        if (menu.opt1_select==1 && !menu.fullscreenfix)
        {
            if (get_config(game)==0)
            {
                game->screen = SDL_SetVideoMode(game->config.resolution_w, game->config.resolution_h, 32, SDL_DOUBLEBUF | SDL_HWSURFACE | SDL_FULLSCREEN);
                menu.fullscreenfix=1;
            }
        }

        else if (menu.opt1_select==0 && !menu.fullscreenfix)
        {
            if (get_config(game)==0)
            {
                game->screen = SDL_SetVideoMode(game->config.resolution_w, game->config.resolution_h, 32, SDL_DOUBLEBUF | SDL_HWSURFACE);
                menu.fullscreenfix=1;
            }

        }


//************************* Affichage du titre **********************

        if (!TITLE_SHOWN)
        {
            for(v=1; v<53; v++)
            {
                if (i>6)
                    i=0;

                i++;

                SDL_BlitSurface(animation[i],NULL,game->screen,&positionfond);
                SDL_BlitSurface(titre[v],NULL,game->screen,&positionfond);
              //  SDL_Delay(5);
                SDL_Flip(game->screen);
                SDL_FreeSurface(titre[v]);


            }
            TITLE_SHOWN=1;
        }

//********************************************************************

//************************ Animation Background *********************

        if (i>6)
            i=0;

        i++;

        SDL_BlitSurface(animation[i],&positionsrc,game->screen,&positionfond);
        if(!menu.SHOW_EXIT)
        {
            SDL_BlitSurface(titre[54],NULL,game->screen,&positionfond);
            for (j=1; j<6; j++)
                SDL_BlitSurface(boutonsA[j],NULL,game->screen,&positionbouton[j-1]);

            switch(menu.etat)
            {
            case 1:
                SDL_BlitSurface(boutonsB[1],NULL,game->screen,&positionbouton[0]);
                break;
            case 2:
                SDL_BlitSurface(boutonsB[2],NULL,game->screen,&positionbouton[1]);
                break;
            case 3:
                SDL_BlitSurface(boutonsB[3],NULL,game->screen,&positionbouton[2]);
                break;
            case 4:
                SDL_BlitSurface(boutonsB[4],NULL,game->screen,&positionbouton[3]);
                break;
            case 5:
                SDL_BlitSurface(boutonsB[5],NULL,game->screen,&positionbouton[4]);
                break;

            }
        }


//*******************************************************************

//***************************** menu exit ***************************
        if (menu.SHOW_EXIT)
        {
            SDL_BlitSurface(exit_menu[0],NULL,game->screen,&positionexit);
            SDL_BlitSurface(exit_menu[1+menu.exit_yes],NULL,game->screen,&positionyes);
            SDL_BlitSurface(exit_menu[3+menu.exit_no],NULL,game->screen,&positionno);

        }

//*******************************************************************

//**************************** menu options *************************
        if (menu.SHOW_OPTION)
        {
            SDL_BlitSurface(options_back,NULL,game->screen,&positionoptions);
            SDL_BlitSurface(options[menu.opt1_select],NULL,game->screen,&positionoption1);
            SDL_BlitSurface(options[menu.opt2_select],NULL,game->screen,&positionoption2);

        }

//*******************************************************************


        SDL_Flip(game->screen);

        if (SDL_PollEvent(&event)==1)
        {
            if (event.type == SDL_QUIT)
            {
                menu.continuer=0;
            }

            else if (event.type == SDL_KEYUP)
            {
                fix=0;
            }


            else  if (event.type == SDL_KEYDOWN)
            {
                if(!fix)
                {
                    switch(event.key.keysym.sym)
                    {
                    case SDLK_DOWN:
                        if (menu.etat!=5 && !menu.SHOW_OPTION && !menu.SHOW_EXIT)
                        {
                            (menu.etat)++;
                            fix=1;
                            Mix_PlayChannel(1, son, 0);
                        }
                        if (menu.SHOW_OPTION)
                        {
                            if (menu.opt2_select==4)
                                menu.opt2_select=6;
                            if (menu.opt2_select==5)
                                menu.opt2_select=7;
                            if (menu.opt1_select==0)
                                menu.opt1_select=2;
                            if (menu.opt1_select==1)
                                menu.opt1_select=3;
                            fix=1;
                        }
                        break;
                    case SDLK_UP:
                        if (menu.etat!=1 && !menu.SHOW_OPTION && !menu.SHOW_EXIT)
                        {
                            (menu.etat)--;
                            fix=1;
                            Mix_PlayChannel(1, son, 0);
                        }

                        if (menu.SHOW_OPTION)
                        {
                            if (menu.opt1_select==2)
                                menu.opt1_select=0;
                            if (menu.opt1_select==3)
                                menu.opt1_select=1;
                            if (menu.opt2_select==6)
                                menu.opt2_select=4;
                            if (menu.opt2_select==7)
                                menu.opt2_select=5;
                            fix=1;
                        }
                        break;
                    case SDLK_RIGHT:
                        if (menu.SHOW_EXIT)
                        {
                            menu.exit_no=1;
                            menu.exit_yes=0;
                            fix=1;
                        }

                        if (menu.SHOW_OPTION)
                        {
                            if (menu.opt1_select==0)
                            {
                                menu.opt1_select=1;
                                menu.fullscreenfix=0;
                            }

                            if (menu.opt2_select==6)
                            {
                                menu.opt2_select=7;
                                Mix_Pause(1);
                                Mix_PauseMusic();
                            }
                            fix=1;
                        }
                        break;
                    case SDLK_LEFT:
                        if (menu.SHOW_EXIT)
                        {
                            menu.exit_no=0;
                            menu.exit_yes=1;
                            fix=1;
                        }
                        if (menu.SHOW_OPTION)
                        {
                            if (menu.opt1_select==1)
                            {
                                menu.opt1_select=0;
                                menu.fullscreenfix=0;
                            }

                            if (menu.opt2_select==7)
                            {
                                menu.opt2_select=6;
                                Mix_ResumeMusic();
                            }
                            fix=1;
                        }
                        break;

                    case SDLK_ESCAPE:
                        menu.SHOW_OPTION=0;
                        menu.SHOW_EXIT=0;
                        fix=1;
                        break;

                    case SDLK_RETURN:
                        fix=1;
                        switch(menu.etat)
                        {
                        case 1:
                            game->level=1;
                            Mix_PauseMusic();
                            menu.continuer=0;
                            break;

                        case 2:
                            load_level(game);
                            Mix_PauseMusic();
                            menu.continuer=0;
                            break;

                        case 3:
                            if (!menu.SHOW_OPTION)
                            {
                                menu.opt1_select=0;
                                menu.opt2_select=4;
                            }

                            menu.SHOW_OPTION=1;
                            fix=1;
                            break;

                        case 4:
                            break; //help

                        case 5:
                            if(!menu.SHOW_EXIT)
                            {
                                menu.exit_yes=1;
                                menu.exit_no=0;
                            }
                            if (menu.SHOW_EXIT)
                            {
                                if (menu.exit_yes)
                                {
                                    menu.continuer=0;
                                }
                                else
                                    menu.SHOW_EXIT=0;
                            }
                            if(menu.exit_no==0)
                                menu.SHOW_EXIT=1;
                            break;

                        default:
                            break;
                        }
                    default:
                        break;
                    }


                }
            }

            else if (event.type == SDL_KEYUP)
            {
                fix=0;
            }

            else if (event.type == SDL_MOUSEBUTTONDOWN && event.motion.y > 370 && event.motion.y < 690)
            {
                fix=1;
                switch(menu.etat)
                {
                case 1:
                    game->level=1;
                    Mix_PauseMusic();
                    menu.continuer=0;
                    break;

                case 2:
                    load_level(game);
                    Mix_PauseMusic();
                    menu.continuer=0;
                    break;

                case 3:
                    if (!menu.SHOW_OPTION)
                    {
                        menu.opt1_select=0;
                        menu.opt2_select=4;
                    }

                    menu.SHOW_OPTION=1;
                    fix=1;
                    break;

                case 4:
                    break; //help

                case 5:
                    if(!menu.SHOW_EXIT)
                    {
                        menu.exit_yes=1;
                        menu.exit_no=0;
                    }
                    if (menu.SHOW_EXIT)
                    {
                        if (menu.exit_yes)
                        {
                            menu.continuer=0;
                        }
                        else
                            menu.SHOW_EXIT=0;
                    }
                    if(menu.exit_no==0)
                        menu.SHOW_EXIT=1;


                    break;

                default:
                    break;
                }


            }

            if (event.type == SDL_MOUSEMOTION && !menu.SHOW_OPTION && !menu.SHOW_EXIT)
            {
                if ((event.motion.y >= 376) && (event.motion.y <= 428))
                {
                    if(!fix_son)
                        Mix_PlayChannel(1, son, 0);
                    menu.etat = 1;
                    fix_son=1;
                }

                else if ((event.motion.y >= 439) && (event.motion.y <= 492))
                {
                    if(!fix_son)
                        Mix_PlayChannel(1, son, 0);
                    menu.etat = 2;
                    fix_son=1;
                }

                else if ((event.motion.y >= 511) && (event.motion.y <= 566))
                {
                    if(!fix_son)
                        Mix_PlayChannel(1, son, 0);
                    menu.etat = 3;
                    fix_son=1;
                }

                else if ((event.motion.y >= 576) && (event.motion.y <= 630))
                {
                    if(!fix_son)
                        Mix_PlayChannel(1, son, 0);
                    menu.etat = 4;
                    fix_son=1;
                }

                else if ((event.motion.y >= 640) && (event.motion.y <= 685))
                {
                    if(!fix_son)
                        Mix_PlayChannel(1, son, 0);
                    menu.etat = 5;
                    fix_son=1;
                }

                else
                    fix_son=0;

            }

            /* else if (event.type==SDL_QUIT)
             {
                 menu.continuer=0;
             }*/
        }
    }



    for (i = 1; i < 10; i++)
    {
        SDL_FreeSurface(animation[i]);
    }
    for (i=1; i<6; i++)
    {
        SDL_FreeSurface(boutonsA[i]);
        SDL_FreeSurface(boutonsB[i]);
    }

    SDL_FreeSurface(options_back);
    for (i = 0; i < 8; i++)
    {
        SDL_FreeSurface(options[i]);
    }
    Mix_PauseMusic();
    Mix_FreeMusic(musique);

    menu.done=1;

    if (menu.etat==5)
        return -1;

    return 0;
}


##### ./enemy.c #####
/**

* @file enemy.c

* @author C Squad

* @version 1.0

* @date May 14, 2016

*/


#include <math.h>
#include "game.h"
#include "functions.h"

unsigned int src_pos=1;

int inrange(GAME *game, int i)
{
    return (sqrt(pow(game->npc[i].position.x-(game->background.scroll_x+game->character.position.x),2))<game->npc[i].vision_range && (game->character.position.y >= game->npc[i].position.y - CHAR_H && game->character.position.y <= game->npc[i].position.y + CHAR_H));
}

int spotted(GAME *game, int i)
{
    return ((game->character.position.x+game->background.scroll_x < game->npc[i].position.x && game->npc[i].direction == -1) || (game->character.position.x+game->background.scroll_x > game->npc[i].position.x && game->npc[i].direction == 1) ) ;
}

void movement_npc(GAME *game, int n)
{

        if (game->npc[n].behavior==PATROL || game->npc[n].behavior==REFRACT)
        {
            if (!game->npc[n].fix)
            {
                game->npc[n].elapsed=SDL_GetTicks();
                game->npc[n].fix=1;
            }


            game->npc[n].position.x+=game->npc[n].speed*game->npc[n].direction;

            if (SDL_TICKS_PASSED(game->npc[n].elapsed, 5000))
            {
                game->npc[n].direction*=(-1);
                game->npc[n].fix=0;
            }

            if (game->npc[n].direction==1)
                game->npc[n].look=0;

            else
                game->npc[n].look=1;

            game->npc[n].actuel++;
            if (game->npc[n].actuel>4)
                game->npc[n].actuel=0;
        }

        else if (game->npc[n].behavior==ATTACK)
        {
            if (game->npc[0].direction==1)
            {
                game->npc[0].look=2;
                game->npc[0].actuel=0;
            }
            else
            {
                game->npc[0].look=2;
                game->npc[0].actuel=1;
            }

		bullet_shot(game, n);

        }



        if (inrange(game,n))
        {
            if (spotted(game,n))
                {
                    if (game->global.get_elapsed_npc[n])
                    {
                        game->global.get_elapsed_npc[n]=0;
                        game->global.elapsed_npc[n] = SDL_GetTicks();
                    }
                    else
                    {
                        if (SDL_TICKS_PASSED(game->global.elapsed_npc[n], 600))
                            game->npc[n].behavior=ATTACK;
                        else
                            game->npc[n].behavior=REFRACT;
                    }

                }

        }
        else
        {
            game->npc[n].behavior=PATROL;
            game->global.get_elapsed_npc[n]=1;
        }




}




##### ./level.h #####
#ifndef LEVEL_H_INCLUDED
#define LEVEL_H_INCLUDED

#include "game.h"

void level1(GAME *game);
void level2(GAME *game);
void level3(GAME *game);
void level4(GAME *game);
void playLevel(GAME *game);
void update_screen(GAME *game);
void getPositions(GAME *game);
void mouvement_level4(GAME *game);
void teleport_next_door(GAME *game);
void movement(GAME *game);
void movement_npc(GAME *game, int n);
int onTexte(GAME *game);
int collision_cercle(Cercle c1, Cercle c2);
void save_level(GAME *game);
void play_music(Music *musique);
void saving_menu(GAME *game, Dialogue dialogue);
int manage_events(GAME *game, SDL_Event *event);
void movement_level3(GAME *game);  // Changed from struct Game* to GAME*
int collision_fall(GAME *game);    // Changed from struct Game* to GAME*
int onGround(GAME *game, Character character);  // Add this declaration
int collision_pente(GAME *game);
void load_level(GAME *game);

#endif // LEVEL_H_INCLUDED


##### ./items.h #####
#ifndef ITEMS_H
#define ITEMS_H
#include "collision.h"
#define MAX_ITEMS 10  // Keep this as the only definition
typedef struct Item
{
int number;
SDL_Surface *image, *description;
SDL_Rect position, blit_pos;
Cercle cercle;
int have, selected, disposable;
}Item;

typedef struct Inventory
{
int count;
Item item[MAX_ITEMS];

}Inventory;

#endif


##### ./character.h #####
#ifndef CHARACTER_H
#define CHARACTER_H



#define CHAR_H_INCLUDED
#include "game.h" // Include game.h FIRST to define GAME
#include "collision.h"
#include "enum.h"


typedef struct Character
{
    SDL_Surface *image;
    SDL_Rect position, src_pos, relativePos;
    Cercle pos_cercle;
    int look, actuel;
    int life, died;
    int elapsed;
    /* Npc vars */
    int vision_range, direction, speed, fix;
    Behavior behavior;
}Character;

#endif // CHAR_H_INCLUDED


##### ./enum.h #####
#ifndef ENUM_H_INCLUDED
#define ENUM_H_INCLUDED

typedef enum Behavior
{
PATROL, FOLLOW, ATTACK, REFRACT
}Behavior;

typedef enum Color
{
NONE, BLUE, RED, GREEN, YELLOW
}Color;

#endif // ENUM_H_INCLUDED


##### ./display.c #####
/**

* @file display.c

* @author C Squad

* @version 1.0

* @date May 14, 2016

*/


#include <SDL/SDL.h>
#include <SDL/SDL_image.h>
#include <SDL/SDL_ttf.h>
#include "game.h"
#include "functions.h"
#include "display.h"

int fix_wasted=0;
void BlitWasted(GAME *game, SDL_Rect pos_screen);

void update_screen(GAME *game)
{
    unsigned int elapsed;
    unsigned int lasttime = SDL_GetTicks();
    int i=0;
    SDL_Rect pos_screen;

    pos_screen.x=0;
    pos_screen.y=(game->config.resolution_h-game->background.image[0]->h)/2;

    game->background.position.x=game->background.scroll_x;
    game->background.position.y=game->background.scroll_y;
    game->background.position.h=PLAT_H;
    game->background.position.w=PLAT_W;

    game->objects.objective.pos_src.w=62;
    game->objects.objective.pos_src.h=90;
    game->objects.objective.pos_src.x=game->global.obj_i*62;
    game->objects.objective.pos_src.y=0;

    if (game->level==1)
    {
        game->character.src_pos.x=CHAR_W*game->character.actuel;
        game->character.src_pos.y=CHAR_H*game->character.look;
        game->character.src_pos.h=CHAR_H;
        game->character.src_pos.w=CHAR_W;
    }
    else
    {
        game->character.src_pos.x=CHAR_BIG_W*game->character.actuel;
        game->character.src_pos.y=CHAR_BIG_H*game->character.look;
        game->character.src_pos.h=CHAR_BIG_H;
        game->character.src_pos.w=CHAR_BIG_W;
    }

    i=(game->background.counter%3)+2;

    if (/*!game->character.died && */game->background.image[0]!=NULL)
    {
        SDL_FillRect(game->screen, NULL, SDL_MapRGB(game->screen->format, 0, 0, 0));
        switch (game->level)
        {
        case 1:
            if (random_case(game))
                SDL_BlitSurface(game->background.image[1],&game->background.position,game->screen,&pos_screen);
            else
                SDL_BlitSurface(game->background.image[0],&game->background.position,game->screen,&pos_screen);

            break;
        case 2:
            if (game->background.counter%10)
                SDL_BlitSurface(game->background.image[1],&game->background.position,game->screen,&pos_screen);
            else
                SDL_BlitSurface(game->background.image[0],&game->background.position,game->screen,&pos_screen);
            if (game->global.level2_show_items)
                SDL_BlitSurface(game->background.image[2],&game->background.position,game->screen,&pos_screen);

            if (game->global.level2_show_items)
            {
                if (game->objects.inventory.item[2].have==0)
                    SDL_BlitSurface(game->objects.inventory.item[2].image,NULL,game->screen,&game->objects.inventory.item[2].blit_pos);
                if (game->objects.inventory.item[3].have==0)
                    SDL_BlitSurface(game->objects.inventory.item[3].image,NULL,game->screen,&game->objects.inventory.item[3].blit_pos);
            }
            break;
        case 3:
            SDL_BlitSurface(game->background.image[i%2],&game->background.position,game->screen,&pos_screen);
            if (game->objects.inventory.item[1].have==0)
                SDL_BlitSurface(game->objects.inventory.item[1].image,NULL,game->screen,&game->objects.inventory.item[1].blit_pos);

            break;
        case 4:
//       SDL_FillRect(game->screen, NULL, SDL_MapRGB(game->screen->format, 0, 0, 0));
            SDL_BlitSurface(game->background.image[0],&game->background.position,game->screen,&pos_screen);
            break;

        }


        game->global.obj_i++;
        if (game->global.obj_i>7)
            game->global.obj_i=0;

        game->objects.objective.pos_src.x=game->global.obj_i*62;
        game->objects.objective.pos_src.y=0;

        if (game->objects.objective.image!=NULL)
            if (PLAT_W+game->background.scroll_x>=game->objects.objective.position.x)
            {
                SDL_BlitSurface(game->objects.objective.image,&game->objects.objective.pos_src,game->screen,&game->objects.objective.relativePos);
            }


        /* --- */
        BlitNPC(game);
        SDL_BlitSurface(game->character.image,&game->character.src_pos,game->screen,&game->character.position);

        if (game->level==1)
            SDL_BlitSurface(game->background.image[i],&game->background.pos_rain,game->screen,&pos_screen);
        if (game->level==4)
        {
            game->global.fire_i++;
            if (game->global.fire_i>3)
                game->global.fire_i=0;

            if (!game->global.FIN)
                SDL_BlitSurface(game->background.image[game->global.fire_i+2],NULL,game->screen,&pos_screen);

        }

        SDL_BlitSurface(game->gui.avatar,NULL,game->screen,&game->gui.pos_avatar);
        game->gui.hp = TTF_RenderText_Solid(game->texte.police, tostr(game->character.life), game->texte.couleur);
        SDL_BlitSurface(game->gui.hp, NULL, game->screen, &game->gui.pos_hp);

        /* inventaire */
        if (game->gui.show_inv)
        {
            show_inventory(game);
        }


        /* Dialogue */
        if (game->gui.show_dialogue)
        {
            SDL_BlitSurface(game->gui.dialogue[game->texte.indice[game->texte.i]], NULL, game->screen, &game->gui.pos_dialogue);
            SDL_BlitSurface(game->gui.btn_animated[i%2], NULL, game->screen, &game->gui.pos_btn);
            blit_text(game);
        }

        /* Shooting */
        blit_bullet(game);

        /* Text */
        if (game->global.show_message)
            show_message(game);


        /* */

        if (game->character.life<=0)// && game->texte.quote!=NULL)
            SDL_BlitSurface(game->texte.quote, NULL, game->screen, NULL);

        if (game->character.died)
        {
            if (!game->global.fix_died)
            {
                game->global.frame_died++;
                if (game->global.frame_died==32)
                    game->global.fix_died=1;
                SDL_Delay(game->global.frame_died);
                pos_screen.x+=100;
                SDL_BlitSurface(game->gui.died[game->global.frame_died], NULL, game->screen, &pos_screen);
                pos_screen.x-=100;
            }
            else
            {
                pos_screen.x+=100;
                SDL_BlitSurface(game->gui.died[32], NULL, game->screen, &pos_screen);
                game->global.frame_died=0;
                pos_screen.x-=100;
            }
        }
        //fix_wasted=0;
    }

    /*else
    {

    }*/


    /* Fixing fps */
    elapsed = SDL_GetTicks()-lasttime;
    if (elapsed<1000/FPS)
        SDL_Delay(1000/FPS-elapsed);

    SDL_Flip(game->screen);
}

void BlitNPC(GAME *game)
{
    SDL_Rect src_npc[5]; //relativePos_npc takes the position relative to camera from actual position


    src_npc[0].x=CHAR_W*game->npc[0].actuel;
    src_npc[0].y=CHAR_H*game->npc[0].look;
    src_npc[0].h=CHAR_H;
    src_npc[0].w=CHAR_W;

    src_npc[1].x=CHAR_W*game->npc[1].actuel;
    src_npc[1].y=CHAR_H*game->npc[1].look;
    src_npc[1].h=CHAR_H;
    src_npc[1].w=CHAR_W;

    src_npc[2].x=CHAR_W*game->npc[2].actuel;
    src_npc[2].y=CHAR_H*game->npc[2].look;
    src_npc[2].h=CHAR_H;
    src_npc[2].w=CHAR_W;

    src_npc[3].x=CHAR_W*game->npc[3].actuel;
    src_npc[3].y=CHAR_H*game->npc[3].look;
    src_npc[3].h=CHAR_H;
    src_npc[3].w=CHAR_W;

    if (game->npc[4].image!=NULL)
    {
        src_npc[4].x=0;//85*game->npc[4].actuel;
        src_npc[4].y=150;//150*game->npc[4].look;
        src_npc[4].h=150;
        src_npc[4].w=78;
    }


    if (game->npc[0].image!=NULL)
        if (PLAT_W+game->background.scroll_x>=game->npc[0].position.x)
        {
            SDL_BlitSurface(game->npc[0].image,&src_npc[0],game->screen,&game->npc[0].relativePos);
        }
    if (game->npc[1].image!=NULL)
        if (PLAT_W+game->background.scroll_x>=game->npc[1].position.x)
        {
            SDL_BlitSurface(game->npc[1].image,&src_npc[1],game->screen,&game->npc[1].relativePos);
        }

    if (game->npc[2].image!=NULL)
        if (PLAT_W+game->background.scroll_x>=game->npc[2].position.x)
        {
            SDL_BlitSurface(game->npc[2].image,&src_npc[2],game->screen,&game->npc[2].relativePos);
        }
    if (game->npc[3].image!=NULL)
        if (PLAT_W+game->background.scroll_x>=game->npc[3].position.x)
        {
            SDL_BlitSurface(game->npc[3].image,&src_npc[3],game->screen,&game->npc[3].relativePos);
        }

    if (game->npc[4].image!=NULL)
    {
        if (PLAT_W+game->background.scroll_x>=game->npc[4].position.x)
        {
            SDL_BlitSurface(game->npc[4].image, &src_npc[4],game->screen, &game->npc[4].relativePos);
        }

    }

}

void getPositions(GAME *game)
{
    int i=0;
    for (i=0; i<5; i++)
        if (game->npc[i].image!=NULL)
        {
            game->npc[i].relativePos.x=relative_x(game,game->npc[i].position);
            game->npc[i].relativePos.y=game->npc[i].position.y;
        }

    for (i=0; i<5; i++)
        //if (game->objects.bullet[i].started)
    {
        game->objects.bullet[i].relativePos.x=relative_x(game, game->objects.bullet[i].position);
        game->objects.bullet[i].relativePos.y=game->objects.bullet[i].position.y;
    }
    game->objects.objective.relativePos.x=relative_x(game, game->objects.objective.position);
    game->objects.objective.relativePos.y=game->objects.objective.position.y;

    game->objects.inventory.item[1].blit_pos.x=game->objects.inventory.item[1].cercle.x;
    game->objects.inventory.item[1].blit_pos.y=game->objects.inventory.item[1].cercle.y;
    game->objects.inventory.item[1].blit_pos.x=relative_x(game, game->objects.inventory.item[1].blit_pos);
    game->objects.inventory.item[2].blit_pos.x=game->objects.inventory.item[2].cercle.x;
    game->objects.inventory.item[2].blit_pos.y=game->objects.inventory.item[2].cercle.y;
    game->objects.inventory.item[2].blit_pos.x=relative_x(game, game->objects.inventory.item[2].blit_pos);
    game->objects.inventory.item[3].blit_pos.x=game->objects.inventory.item[3].cercle.x;
    game->objects.inventory.item[3].blit_pos.y=game->objects.inventory.item[3].cercle.y;
    game->objects.inventory.item[3].blit_pos.x=relative_x(game, game->objects.inventory.item[3].blit_pos);
}

void show_message(GAME *game)
{
    game->texte.texte = TTF_RenderText_Solid(game->texte.police, game->texte.message, game->texte.couleur);
    SDL_BlitSurface(game->texte.texte, NULL, game->screen, &game->texte.position);
}


void BlitWasted(GAME *game, SDL_Rect pos_screen)
{
    int i=0;
    for (i=1; i<32; i++)
    {
        SDL_BlitSurface(game->gui.died[i], NULL, game->screen, &pos_screen);
        SDL_Flip(game->screen);
        SDL_Delay(40);
    }
}


##### ./collisions.c #####
/**

* @file collisions.c

* @author C Squad

* @version 1.0

* @date May 14, 2016

*/

#include <math.h>
#include "game.h"
#include "collision.h"

int collision_cercle(Cercle c1, Cercle c2)
{
    return(sqrt(pow((c1.x-c2.x),2)+pow((c1.y-c2.y),2)) <= (c1.r+c2.r));
}


int collision_box(Box b1, Box b2)
{
    return(b1.x > b2.x-8 && b1.x < b2.x+8);
}

//Lire les couleurs d'un pixel
SDL_Color GetPixel(SDL_Surface *Background, int x, int y)
{
    SDL_Color color, black={255,255,255};
    Uint32 col = 0;
    //Determine position

if (x<10000 && y<600)
{
    char *pixelPosition = (char*)Background->pixels;
    //Offset by Y
    pixelPosition += (Background->pitch * y);
    //Offset by X
    pixelPosition += (Background->format->BytesPerPixel * x);
    //Copy pixel data
    memcpy(&col, pixelPosition, Background->format->BytesPerPixel);
    //Convert to color
    SDL_GetRGB(col, Background->format, &color.r, &color.g, &color.b);

    return (color);
}
else
    return (black);

}

int Collision_PPP(struct GAME *game, Character perso)
{
    SDL_Color PixelToCompare;

SDL_LockSurface(game->background.levelCollision);
    if (game->input.left)
    {
        if (game->character.position.x + game->background.scroll_x + game->character.position.w*3/4 > 0)
        PixelToCompare = GetPixel(game->background.levelCollision, game->character.position.x + game->background.scroll_x+game->character.position.w/4, game->character.position.y+game->character.position.h-(game->config.resolution_h-game->background.levelCollision->h)/2-12);

        return ((PixelToCompare.r == 255) && (PixelToCompare.b == 255) && (PixelToCompare.g == 255));
    }

    if (game->input.right)
    {
        if (game->character.position.x + game->background.scroll_x + game->character.position.w*3/4 < game->background.levelCollision->w)
        PixelToCompare = GetPixel(game->background.levelCollision, game->character.position.x + game->background.scroll_x + game->character.position.w*3/4, game->character.position.y+game->character.position.h-(game->config.resolution_h-game->background.levelCollision->h)/2-12);

        return ((PixelToCompare.r == 255) && (PixelToCompare.b == 255) && (PixelToCompare.g == 255));
    }
SDL_UnlockSurface(game->background.levelCollision);
    return 0;
}

int onGround(struct GAME *game, Character perso)
{
    SDL_Color PixelToCompare;
    PixelToCompare = GetPixel(game->background.levelCollision /*Background*/, game->character.position.x + game->background.scroll_x + game->character.position.w / 2, game->character.position.y+game->character.position.h-(game->config.resolution_h-game->background.levelCollision->h)/2);
    return ((PixelToCompare.r == 255) && (PixelToCompare.b == 255) && (PixelToCompare.g == 255));
}
/*
int onGround(GAME *game, Character perso)
{
    SDL_Color PixelToCompare;
    PixelToCompare = GetPixel(game->background.levelCollision , game->character.position.x + game->background.scroll_x + game->character.position.w / 2, game->character.position.y+game->character.position.h-(game->config.resolution_h-PLAT_H)/2);
    return ((PixelToCompare.r == 255) && (PixelToCompare.b == 255) && (PixelToCompare.g == 255));
}*/

int onTexte(GAME *game)
{
    SDL_Color PixelToCompare;
    PixelToCompare = GetPixel(game->background.levelCollision, game->character.position.x + game->background.scroll_x + game->character.position.w / 2, game->character.position.y+game->character.position.h/2-(game->config.resolution_h-game->background.levelCollision->h)/2);

    if ((PixelToCompare.b == 0) && (PixelToCompare.g == 0) && (PixelToCompare.r%50==0))
        return (PixelToCompare.r / 50);
    else
        return 0;
}


int collision_pente(struct GAME *game)
{
/* Given actual position x1 checks if f(x2)=ax2 is a white pixel, if so then we have a slope */
/* for x1=0 and x2=10 f(x2)=4 */

    SDL_Color PixelToCompare;
    PixelToCompare = GetPixel(game->background.levelCollision, game->character.position.x +10+ game->background.scroll_x + game->character.position.w / 2, game->character.position.y+GRAVITY-4+game->character.position.h-(game->config.resolution_h-game->background.levelCollision->h)/2);

    return ((PixelToCompare.r == 255) && (PixelToCompare.b == 255) && (PixelToCompare.g == 255));
}


int collision_fall(struct GAME *game)
{
    SDL_Color PixelToCompare;
    PixelToCompare = GetPixel(game->background.levelCollision, game->character.position.x + game->background.scroll_x + game->character.position.w / 2, game->character.position.y+game->character.position.h-(game->config.resolution_h-game->background.levelCollision->h)/2);
    return ((PixelToCompare.r == 255) && (PixelToCompare.b == 0) && (PixelToCompare.g == 0));
}

Color collision_color(GAME *game)
{
    SDL_Color PixelToCompare;
    PixelToCompare = GetPixel(game->background.levelCollision, game->character.position.x + game->background.scroll_x + game->character.position.w / 2, game->character.position.y+game->character.position.h/2-(game->config.resolution_h-game->background.levelCollision->h)/2);
    if ((PixelToCompare.r == 255) && (PixelToCompare.b == 0) && (PixelToCompare.g == 0))
        return RED;
    else if ((PixelToCompare.r == 0) && (PixelToCompare.b == 255) && (PixelToCompare.g == 0))
        return BLUE;
    else if ((PixelToCompare.r == 0) && (PixelToCompare.b == 0) && (PixelToCompare.g == 255))
        return GREEN;
    else if ((PixelToCompare.r == 255) && (PixelToCompare.b == 0) && (PixelToCompare.g == 255))
        return YELLOW;
    else
        return NONE;
}


##### ./menu.h #####
#ifndef MENU_H_INCLUDED
#define MENU_H_INCLUDED

typedef struct Menu
{
	int etat;
	int done, getInput;
	int continuer;
	int opt1_select, opt2_select;
	int SHOW_EXIT, SHOW_OPTION;
	int exit_yes, exit_no;
	int intro;
    int continue_level;
    int fullscreenfix;

}Menu;


#endif // MENU_H_INCLUDED


##### ./game.h #####
#ifndef GAME_H
#define GAME_H

#include <SDL/SDL.h>
#include <SDL/SDL_image.h>
#include <SDL/SDL_ttf.h>
#include <SDL/SDL_mixer.h>
#include <SDL/SDL_thread.h>
#include <SDL/SDL_types.h>

#include "declarations.h"
#include "character.h"
#include "objects.h"


#define START_Y (game->config.resolution_h-game->background.image[0]->h)/2
#define TRUE_X (game->background.scroll_x+game->character.position.x)
#define MAX_ITEMS 10  // Adjust based on your needs

typedef struct Config
{
	FILE *f;
	int resolution_w, resolution_h;
	int fullscreen;
}Config;


typedef struct Music
{
	Mix_Music *ambient;

}Music;


typedef struct Background
{
    SDL_Surface *image[7];
    SDL_Surface *levelCollision;
    SDL_Rect position, pos_rain;
    int scroll_x;
    int scroll_y;
    int counter;
}Background;

typedef struct Input
{
	int left, right, up, down, enter, fix;
    int startJump, jumpHeight;

}Input;


typedef struct GUI
{
    SDL_Surface *avatar, *hp, *inventaire, *died[33];
    SDL_Surface *dialogue[5], *btn_animated[2];
    SDL_Rect pos_dialogue, pos_btn;
    SDL_Rect pos_avatar, pos_hp, pos_inv;
	SDL_Surface *frame;

    int show_dialogue, show_inv, indice;
}GUI;

typedef struct Global
{
    int elapsed_npc[5], get_elapsed_npc[5];
    int obj_i, EOL; //EOL = end of level
    int fix, animate;
    int show_message;
    int movement;
    int on_door;
    int FIN;
    int fire_i;
	int fix_died, frame_died;
	int level2_show_items;
    int stopDisplay;
    int green_item, blue_item;
    int checkpoint;
    int fix_tutorial;
    int on_tutorial;
}Global;

typedef struct GAME
{
	SDL_Surface *screen;
	Background background;
	Input input, arduino;
	Character character, npc[5];
	Texte texte;
	Objects objects;
    	GUI gui;
    	Music musique;
    	Global global;
    	Config config;
    	Dialogue dialogue;

	int level, showMenu;
    	int sprite;

}GAME;

#include "collision.h"

#endif


##### ./arduinoReadWrite.c #####
#include <termios.h>  // For serial port configuration
#include <fcntl.h>    // For file control (opening serial ports)
#include <unistd.h>   // For POSIX system calls like read/write
#include <stdio.h>    // For standard I/O (printf, perror)

/**
 * @file ArduinoReadWrite.c
 * @author C Squad
 * @brief Serial communication
 * @version 1.0
 * @date May 24, 2016
 */

int openSerial(int *fd) {
    *fd = open("/dev/ttyUSB0", O_RDWR | O_NOCTTY | O_NDELAY);
    if (*fd < 0) {
        perror("Error opening serial port");
        return 0;
    }

    struct termios tty;
    if (tcgetattr(*fd, &tty) < 0) {
        perror("Error getting serial port attributes");
        close(*fd);
        return 0;
    }

    // Configure serial port settings
    cfsetospeed(&tty, B9600);  // Baud rate 9600
    cfsetispeed(&tty, B9600);

    tty.c_cflag &= ~PARENB;    // No parity
    tty.c_cflag &= ~CSTOPB;    // 1 stop bit
    tty.c_cflag &= ~CSIZE;     // Clear data size
    tty.c_cflag |= CS8;        // 8 bits
    tty.c_cflag |= CREAD | CLOCAL;  // Enable receiver, ignore modem control lines

    // Apply settings
    if (tcsetattr(*fd, TCSANOW, &tty) < 0) {
        perror("Error setting serial port attributes");
        close(*fd);
        return 0;
    }

    return 1;
}

int arduinoWrite(int *fd) {
    char lpBuffer = 'A';
    ssize_t bytesWritten = write(*fd, &lpBuffer, sizeof(lpBuffer));
    if (bytesWritten < 0) {
        perror("Error writing to serial port");
        close(*fd);
        return 0;
    }
    return 1;  // Success
}


##### ./objects.h #####
#ifndef OBJECTS_H
#define OBJECTS_H
#include "items.h"
#include "bullet.h"

typedef struct Dialogue
{
	int interrupt ;
	int saving_state;
	int choice;
	SDL_Surface *choicy;
	SDL_Surface *dialogue;
	SDL_Surface *btnYes;
	SDL_Surface *btnNo;
	SDL_Surface *saveYESa;
	SDL_Surface *saveYESb;
	SDL_Surface *saveNOa;
	SDL_Surface *saveNOb;

	SDL_Rect positionChoice;
	SDL_Rect positionD;
	SDL_Rect positionYES;
	SDL_Rect positionNO;
}Dialogue;

typedef struct Texte
{
SDL_Surface *texte;
SDL_Rect position;
TTF_Font *police;
SDL_Color couleur;
FILE *f;
int actuel,i,fix,line, indice[26];

char ch[6], aux[100], dialogue[26][100];
char message[100];

char text_quote[60];
SDL_Surface *quote;
SDL_Rect pos_quote;

}Texte;

typedef struct Particle
{
    SDL_Surface *image;
	SDL_Rect pos_src, position, relativePos;
	Cercle cercle;
}Particle;

typedef struct Borders
{
    int left[6], right[6];
}Borders;

typedef struct Objects
{
	Bullet bullet[5];
	unsigned int elapsed;

    Particle objective;
    Borders borders;
    Cercle door[12];
	Inventory inventory;
	SDL_Surface *tutorial[10];
	SDL_Rect pos_tuto;

}Objects;


#endif


##### ./bullet.c #####
/**

* @file bullet.c

* @author C Squad

* @version 1.0

* @date May 14, 2016

*/

#include <math.h>
#include <string.h>
#include "game.h"
#include "functions.h"

#define BULLET_TICKS 4000

int collision_cercle(Cercle c1, Cercle c2);

int get_elapsed=1;

void init_bullet(GAME *game, int a, int b) /* a: npc id     b: bullet id */
{
    if (game->character.position.x+game->background.scroll_x<game->npc[a].position.x)
    {
        game->objects.bullet[b].direction=-1;
        game->objects.bullet[b].position.x=game->npc[a].position.x;
        game->objects.bullet[b].position.y=game->npc[a].position.y+15;
    }
    else
    {
        game->objects.bullet[b].direction=1;
        game->objects.bullet[b].position.x=game->npc[a].position.x+20;
        game->objects.bullet[b].position.y=game->npc[a].position.y+15;

    }
}

void blit_bullet(GAME *game)
{
    int i=0;

    SDL_Rect src_bullet;
    src_bullet.x=0;
    src_bullet.y=0;
    src_bullet.h=12;
    src_bullet.w=20;

    for (i=0; i<5; i++)
    {
        if (SDL_TICKS_PASSED(game->objects.bullet[i].ticks, BULLET_TICKS))
            game->objects.bullet[i].started=0;

        if (game->objects.bullet[i].started)
        {
            game->objects.bullet[i].position.x+=game->objects.bullet[i].direction*game->objects.bullet[i].speed;
            game->objects.bullet[i].cercle.x=game->objects.bullet[i].position.x;
            game->objects.bullet[i].cercle.y=game->objects.bullet[i].position.y;


            SDL_BlitSurface(game->objects.bullet[i].image, &src_bullet, game->screen, &game->objects.bullet[i].relativePos);


            /* collision start */
            if (!game->character.died)
                if (collision_cercle(game->character.pos_cercle,game->objects.bullet[i].cercle))
                {
                    game->character.died=1;
                    game->character.life--;
                    game->objects.bullet[i].started=0;
                }
            /* collision end */
        }
    }

}


void bullet_shot(GAME *game, int a)  /* a: npc id */
{
    int i=0;

    if (get_elapsed)
    {
        game->objects.elapsed=SDL_GetTicks();
        get_elapsed=0;


        while (i<5)
        {
            if (!game->objects.bullet[i].started)
            {
                init_bullet(game,a,i);
                game->objects.bullet[i].ticks=SDL_GetTicks();
                game->objects.bullet[i].started=1;

                if (SDL_TICKS_PASSED(game->objects.bullet[i].ticks, BULLET_TICKS))
                    get_elapsed=0;
                i=5;

            }
            else
                i++;
        }

    }
            if (SDL_TICKS_PASSED(game->objects.elapsed, RELOAD))
            get_elapsed=1;
}


/*
void bullet_shot(GAME *game, int a)   a: npc id   -- old fct
{
    int i=0;

    //if (!game->objects.bullet[0].started)
    if (get_elapsed)
        {
            game->objects.elapsed=SDL_GetTicks();
            get_elapsed=0;
        }

    for (i=0; i<5; i++)
    {
        if (!game->character.died)
            if (collision_cercle(game->character.pos_cercle,game->objects.bullet[i].cercle))
            {
                game->character.died=1;
                game->character.life--;
                game->objects.bullet[i].started=0;
            }

        if (SDL_TICKS_PASSED(game->objects.elapsed,i*RELOAD))
        {
            if (!game->objects.bullet[i].started)
            {
                init_bullet(game,a,i);
                game->objects.bullet[i].started=1;
   //             fprintf(stderr,"he %d\n",game->objects.bullet[i].position.x);
            }
        }
        if (i==4)
            if (SDL_TICKS_PASSED(game->objects.elapsed,(i+1)*RELOAD))
                get_elapsed=1;
    }
}
*/


##### ./functions.c #####
/**

* @file functions.c

* @author C Squad

* @version 1.0

* @date May 14, 2016

*/


#include <SDL/SDL.h>
#include <SDL/SDL_image.h>
#include <math.h>
#include <SDL/SDL_ttf.h>
#include <SDL/SDL_mixer.h>   // For SDL_mixer functions
#include <string.h>
#include "game.h"
#include "functions.h"

void init_items(GAME *game);

void init_input(GAME *game)
{
    game->input.right=0;
    game->input.left=0;
    game->input.up=0;
    game->input.down=0;
    game->input.fix=0;
    game->input.enter=0;
    game->input.startJump=0;
    game->input.jumpHeight=0;

    game->arduino.right=0;
    game->arduino.left=0;
    game->arduino.up=0;
}

void init_characters(GAME *game)
{

    /* character principal */
    game->character.position.x=434;
    game->character.position.y=game->config.resolution_h-600;
    game->character.life=3;
    game->character.actuel=0;
    game->character.look=0;
    game->character.pos_cercle.r=30;
    game->character.speed=12;

    /* npc's */
    if (game->level==1)
    {
        game->character.speed=12;

        /* enemy 1*/
        game->npc[0].position.x=2500;
        game->npc[0].position.y=START_Y+465;
        game->npc[0].direction=1;
        game->npc[0].fix=0;
        game->npc[0].life=1;
        game->npc[0].actuel=0;
        game->npc[0].look=0;
        game->npc[0].speed=1;
        game->npc[0].vision_range=350;
        game->npc[0].behavior=PATROL;

        /* officer */
        game->npc[1].position.x=542;
        game->npc[1].position.y=START_Y+465;
        game->npc[1].direction=0;
        game->npc[1].fix=0;
        game->npc[1].life=100;
        game->npc[1].actuel=0;
        game->npc[1].look=0;
        game->npc[1].speed=0;
        game->npc[1].vision_range=0;

        /* enemy 2 & 3 */
        game->npc[2].position.x=4900;
        game->npc[2].position.y=START_Y+465;
        game->npc[2].direction=1;
        game->npc[2].fix=0;
        game->npc[2].life=1;
        game->npc[2].actuel=0;
        game->npc[2].look=0;
        game->npc[2].speed=1;
        game->npc[2].vision_range=330;
        game->npc[2].behavior=PATROL;

        game->npc[3].position.x=5800;
        game->npc[3].position.y=START_Y+465;
        game->npc[3].direction=-1;
        game->npc[3].actuel=1;
        game->npc[3].look=2;
        game->npc[3].speed=1;
        game->npc[3].vision_range=330;
        game->npc[3].behavior=PATROL;

        game->character.position.y+=300;
    }
    else if (game->level==2)
    {
        game->npc[4].position.x=8280;
        game->npc[4].position.y=START_Y+400;
        game->npc[4].direction=1;
        game->npc[4].actuel=0;
        game->npc[4].look=2;
        game->npc[4].speed=0;
        game->npc[4].vision_range=350;
        game->npc[4].behavior=REFRACT;
        game->character.speed=16;
    }
     else  if (game->level==3)
       {
         game->character.position.x=850;
          game->character.position.y+=200;
          game->character.speed=10;
       }

    else if (game->level==4)
        {
            game->character.position.x=game->config.resolution_w/2-120;
            game->character.speed=12;
        }


}

void init_global_vars(GAME *game)
{
    int i=0;
    game->global.EOL=0;
    game->gui.pos_dialogue.x=(game->config.resolution_w-game->gui.dialogue[0]->w)/2;
    game->gui.pos_dialogue.y=90;
    game->gui.pos_btn.x=(game->config.resolution_w-game->gui.dialogue[0]->w)/2 + 900;
    game->gui.pos_btn.y=580;

    game->background.pos_rain.h=PLAT_H;
    game->background.pos_rain.w=PLAT_W;
    game->background.pos_rain.x=0;
    game->background.pos_rain.y=0;

    game->texte.indice[0]=1;
    game->global.fix=0;
    game->global.stopDisplay=0;

    for (i=0; i<5; i++) //bullet
    {
        game->objects.bullet[i].started=0;
        game->objects.bullet[i].speed=26;
        game->objects.bullet[i].direction=0;
        game->objects.bullet[i].cercle.r=10;
        game->objects.bullet[i].cercle.x=0;
        game->objects.bullet[i].cercle.y=0;
        game->global.get_elapsed_npc[i]=1;

    }


    game->texte.actuel=0;
    game->texte.i=0;

    game->texte.couleur.r = 255;
    game->texte.couleur.g = 255;
    game->texte.couleur.b = 255;

    game->background.scroll_x=0;
    game->background.scroll_y=0;
    game->background.counter=0;

    if (game->level==3)
        game->background.scroll_x=10000-game->config.resolution_w;


    game->gui.show_dialogue=0;
    game->gui.show_inv=0;

    game->character.died=0;

    game->character.pos_cercle.r=30;

    game->global.obj_i=0;
    game->global.show_message=0;
    game->sprite=2;

    game->global.movement=0;
    game->global.on_door=0;
    game->texte.fix=0;

    game->global.FIN=0;
    game->global.fire_i=0;


game->global.fix_died=0;
game->global.frame_died=0;
game->global.on_door=0;


}

void init_private_vars(GAME *game)
{
      int i=0;

    switch(game->level)
    {
    case 1:
        game->global.checkpoint=0;

        game->objects.objective.position.x=8600;
        game->objects.objective.position.y=START_Y+480;
        game->objects.objective.cercle.x=8600;
        game->objects.objective.cercle.y=START_Y+480;
        game->objects.objective.cercle.r=20;


        game->gui.pos_avatar.x=20;
        game->gui.pos_avatar.y=START_Y+15;
        game->gui.pos_hp.x=120;
        game->gui.pos_hp.y=START_Y+110;

        /* borders */
        game->objects.borders.left[0]=0;
        game->objects.borders.right[0]=10000;
        game->objects.borders.left[1]=-1;
        game->objects.borders.right[1]=-1;

		game->objects.inventory.item[0].number=0;
		game->objects.inventory.ite