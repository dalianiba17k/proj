m[0].have=1;
		game->objects.inventory.item[0].selected=1;
		game->objects.inventory.count=1;

		 game->global.fix_tutorial=0;
		 game->global.on_tutorial=0;


        break;
    case 2:
        game->global.checkpoint=0;

        game->objects.objective.position.x=9340;
        game->objects.objective.position.y=START_Y+460;
        game->objects.objective.cercle.x=9340;
        game->objects.objective.cercle.y=START_Y+460;
        game->objects.objective.cercle.r=40;

        game->gui.pos_avatar.x=25;
        game->gui.pos_avatar.y=100;
        game->gui.pos_hp.x=125;
        game->gui.pos_hp.y=195;

		game->global.level2_show_items=0;

        /* borders */
        game->objects.borders.left[0]=0;
        game->objects.borders.right[0]=4020;

        game->objects.borders.left[1]=4020;
        game->objects.borders.right[1]=5350;

        game->objects.borders.left[2]=5300;
        game->objects.borders.right[2]=6830;

        game->objects.borders.left[3]=6850;
        game->objects.borders.right[3]=8870;

        game->objects.borders.left[4]=9000;
        game->objects.borders.right[4]=10000;
        game->objects.borders.left[5]=-1;
        game->objects.borders.right[5]=-1;

        /*doors*/
        for (i=0;i<5;i++)
        {
            game->objects.door[i].x=game->objects.borders.right[i]-150;
            game->objects.door[i].y=START_Y+460;
            game->objects.door[i].r=120;
        }

        game->objects.door[1].x=5200;



		game->objects.inventory.item[0].number=0;
		game->objects.inventory.item[0].have=0;
		game->objects.inventory.item[0].selected=1;
		game->objects.inventory.count=1;

		game->objects.inventory.item[1].number=0;
		game->objects.inventory.item[1].have=0;
		game->objects.inventory.item[1].selected=0;
		game->objects.inventory.count=1;


		game->objects.inventory.item[2].number=0;
		game->objects.inventory.item[2].have=0;
		game->objects.inventory.item[2].selected=0;
        game->objects.inventory.item[2].cercle.x=2000;
		game->objects.inventory.item[2].cercle.y=START_Y+530;
		game->objects.inventory.item[2].cercle.r=100;
		game->objects.inventory.item[2].disposable=1;


		game->objects.inventory.item[3].number=2;
		game->objects.inventory.item[3].have=0;
		game->objects.inventory.item[3].selected=0;
        game->objects.inventory.item[3].cercle.x=5700;
		game->objects.inventory.item[3].cercle.y=START_Y+530;
		game->objects.inventory.item[3].cercle.r=100;
		game->objects.inventory.item[3].disposable=1;


        break;
    case 3:
        game->global.checkpoint=0;

        game->objects.objective.position.x=294;
        game->objects.objective.position.y=532;
        game->objects.objective.cercle.x=350;
        game->objects.objective.cercle.y=500;
        game->objects.objective.cercle.r=40;

        game->gui.pos_avatar.x=25;
        game->gui.pos_avatar.y=100;
        game->gui.pos_hp.x=125;
        game->gui.pos_hp.y=195;

        /* borders */
        game->objects.borders.left[0]=0;
        game->objects.borders.right[0]=10000;
        game->objects.borders.left[1]=-1;
        game->objects.borders.right[1]=-1;
		game->objects.borders.left[2]=0;
        game->objects.borders.right[2]=10000;
		game->objects.borders.left[3]=0;
        game->objects.borders.right[3]=10000;
		game->objects.borders.left[4]=0;
        game->objects.borders.right[4]=10000;
		game->objects.borders.left[5]=0;
        game->objects.borders.right[5]=10000;

		/* doors */
		game->objects.door[0].x=7600;
        game->objects.door[0].y=START_Y+460;
        game->objects.door[0].r=80;
		game->objects.door[1].x=7162;
		game->objects.door[1].y=START_Y+460;
		game->objects.door[1].r=80;
		game->objects.door[2].x=6300;
		game->objects.door[2].y=START_Y+460;
		game->objects.door[2].r=80;
		game->objects.door[3].x=5690;
		game->objects.door[3].y=START_Y+460;
		game->objects.door[3].r=80;
		game->objects.door[4].x=5265;
		game->objects.door[4].y=START_Y+460;
		game->objects.door[4].r=80;
		game->objects.door[5].x=4825;
		game->objects.door[5].y=START_Y+460;
		game->objects.door[5].r=80;
		game->objects.door[6].x=4185;
		game->objects.door[6].y=START_Y+460;
		game->objects.door[6].r=80;
		game->objects.door[7].x=3310;
		game->objects.door[7].y=START_Y+460;
		game->objects.door[7].r=80;
		game->objects.door[8].x=2711;
		game->objects.door[8].y=START_Y+460;
		game->objects.door[8].r=80;
		game->objects.door[9].x=2291;
		game->objects.door[9].y=START_Y+460;
		game->objects.door[9].r=80;
		game->objects.door[10].x=1835;
		game->objects.door[10].y=START_Y+460;
		game->objects.door[10].r=80;

		/* coin */
		game->objects.inventory.item[1].number=0;
		game->objects.inventory.item[1].cercle.x=9400;
		game->objects.inventory.item[1].cercle.y=START_Y+530;
		game->objects.inventory.item[1].cercle.r=100;
		game->objects.inventory.item[1].have=0;
		game->objects.inventory.item[1].disposable=1;



        break;

    case 4:
        game->global.checkpoint=0;

        game->objects.objective.position.x=9850;
        game->objects.objective.position.y=START_Y+460;;
        game->objects.objective.cercle.x=9600;
        game->objects.objective.cercle.y=START_Y+460;;
        game->objects.objective.cercle.r=60;

        game->gui.pos_avatar.x=25;
        game->gui.pos_avatar.y=100;
        game->gui.pos_hp.x=125;
        game->gui.pos_hp.y=195;

        /* borders */
        game->objects.borders.left[0]=8000;
        game->objects.borders.right[0]=10000;
        game->objects.borders.left[1]=-1;
        game->objects.borders.right[1]=-1;

        break;
    }
}
void init_variables(GAME *game)
{
  init_global_vars(game);
  init_private_vars(game);

}


void load_images(GAME *game)
{
    int i = 0;
    char died[30] = " ";
    for (i = 0; i < 5; i++)
        game->npc[i].image = NULL;

    game->gui.avatar = IMG_Load("DATA/GFX/GUI/Avatar.png");

    game->gui.btn_animated[0] = IMG_Load("DATA/GFX/GUI/up.png");
    game->gui.btn_animated[1] = IMG_Load("DATA/GFX/GUI/down.png");

    game->gui.inventaire = IMG_Load("DATA/GFX/inventory/inventory.png");
    game->gui.frame = IMG_Load("DATA/GFX/inventory/frame.png");

    if (game->level == 1)
        game->character.image = IMG_Load("DATA/GFX/spritesheets/john_level1.png");
    else
        game->character.image = IMG_Load("DATA/GFX/spritesheets/sprites2.png");

    for (i = 1; i < 33; i++)
    {
        sprintf(died, "DATA/GFX/WASTED/%d.png", i);
        game->gui.died[i] = IMG_Load(died);
    }

    switch (game->level)
    {
    case 1:
        game->gui.dialogue[0] = IMG_Load("DATA/GFX/GUI/Dialogue_JOHN.png");
        game->gui.dialogue[1] = IMG_Load("DATA/GFX/GUI/Dialogue_POLICE.png");

        game->background.image[0] = IMG_Load("DATA/GFX/Levels/Level1-1.png");
        game->background.image[1] = IMG_Load("DATA/GFX/Levels/Level1-2.png");
        game->background.image[2] = IMG_Load("DATA/GFX/Levels/rain-1.png");
        game->background.image[3] = IMG_Load("DATA/GFX/Levels/rain-2.png");
        game->background.image[4] = IMG_Load("DATA/GFX/Levels/rain-3.png");
        game->background.levelCollision = IMG_Load("DATA/GFX/Levels/Level1-Collision.png");

        game->npc[0].image = IMG_Load("DATA/GFX/spritesheets/bad_guy1.png");
        game->npc[1].image = IMG_Load("DATA/GFX/spritesheets/police.png");
        game->npc[2].image = IMG_Load("DATA/GFX/spritesheets/bad_guy1.png");
        game->npc[3].image = IMG_Load("DATA/GFX/spritesheets/bad_guy1.png");

        game->objects.tutorial[0] = IMG_Load("DATA/GFX/tutorial/frame.png");
        for (i = 1; i < 9; i++)
        {
            sprintf(died, "DATA/GFX/tutorial/%d.bmp", i);
            game->objects.tutorial[i] = IMG_Load(died);
        }
        game->objects.pos_tuto.x = game->config.resolution_w / 2 - 150;
        game->objects.pos_tuto.y = game->config.resolution_h / 2 - 150;

        break;

    case 2:
        game->gui.dialogue[0] = IMG_Load("DATA/GFX/GUI/Dialogue_JOHN.png");
        game->gui.dialogue[1] = IMG_Load("DATA/GFX/GUI/Dialogue_BARMAN.png");
        game->gui.dialogue[2] = IMG_Load("DATA/GFX/GUI/Dialogue_WADE.png");

        game->npc[4].image = IMG_Load("DATA/GFX/spritesheets/jazzar1.png");

        game->background.image[0] = IMG_Load("DATA/GFX/Levels/Level2-1.png");
        game->background.image[1] = IMG_Load("DATA/GFX/Levels/Level2-2.png");
        game->background.image[2] = IMG_Load("DATA/GFX/Levels/All Items.png");
        game->background.levelCollision = IMG_Load("DATA/GFX/Levels/Level2-Collision.png");
        break;

    case 3:
        game->gui.dialogue[0] = IMG_Load("DATA/GFX/GUI/Dialogue_JOHN.png");
        // game->gui.dialogue[1] = IMG_Load("DATA/GFX/GUI/Dialogue_POLICE.png");

        game->background.image[0] = IMG_Load("DATA/GFX/Levels/Level3-1.png");
        game->background.image[1] = IMG_Load("DATA/GFX/Levels/Level3-2.png");
        game->background.levelCollision = IMG_Load("DATA/GFX/Levels/Level3-Collision.png");
        break;

    case 4:
        game->gui.dialogue[0] = IMG_Load("DATA/GFX/GUI/Dialogue_JOHN.png");

        game->background.image[0] = IMG_Load("DATA/GFX/Levels/Level4.png");
        game->background.image[1] = IMG_Load("DATA/GFX/Fire/1.png");
        game->background.image[2] = IMG_Load("DATA/GFX/Fire/2.png");
        game->background.image[3] = IMG_Load("DATA/GFX/Fire/3.png");
        game->background.image[4] = IMG_Load("DATA/GFX/Fire/4.png");
        game->background.image[5] = IMG_Load("DATA/GFX/Fire/5.png");
        game->background.levelCollision = IMG_Load("DATA/GFX/Levels/Level4-Collision.png");
        break;
    }

    for (i = 0; i < 5; i++)
        game->objects.bullet[i].image = IMG_Load("DATA/GFX/spritesheets/bullet.png");

    game->objects.objective.image = IMG_Load("DATA/GFX/spritesheets/objective.png");
}

void init_level(GAME *game)
{
    init_input(game);
    load_images(game);
	init_items(game);
    init_variables(game);
    init_characters(game);


    game->texte.police = TTF_OpenFont("DATA/fonts/FSEX300.ttf", 24);

    char dlg[25]=" ";
    sprintf(dlg,"DATA/texte/level%d.dlg",game->level);
    game->texte.f=fopen(dlg,"r");


    SDL_FillRect(game->screen, NULL, SDL_MapRGB(game->screen->format, 0, 0, 0));
    loading_screen(game);

}

/* Fin Initialisation */

void loading_screen(GAME *game)
{

    SDL_Surface *loading[4];
    SDL_Rect position_src= {PLAT_H,PLAT_W,0,0}, position_dst= {PLAT_H,PLAT_W,0,0};

    position_dst.y=0;
    position_dst.x=(game->config.resolution_w-1167)/2;

    position_src.y=PLAT_H;
    position_src.x=0;
    position_src.h=600;
    position_src.w=1167;

    int i=0, j=0;

    loading[0]=IMG_Load("DATA/GFX/loading screen/Boss_before.jpg");
    loading[1]=IMG_Load("DATA/GFX/loading screen/Boss_after.jpg");
    loading[2]=IMG_Load("DATA/GFX/loading screen/Wade_before.jpg");
    loading[3]=IMG_Load("DATA/GFX/loading screen/Wade_after.jpg");

    j=(rand()%2)*2;
    SDL_BlitSurface(loading[j],NULL,game->screen,&position_dst);

    while(position_src.y>0)
    {
        position_src.y-=rand()%6;
        position_src.h=game->config.resolution_h-position_src.y;
        position_dst.y=position_src.y;
        if (position_src.y<0)
            position_src.y=0;

        SDL_BlitSurface(loading[j+1],&position_src,game->screen,&position_dst);
        SDL_Flip(game->screen);
    }

    for (i=0; i<4; i++)
        SDL_FreeSurface(loading[i]);


}

void blit_text(GAME *game)
{
    if (!game->texte.fix)
    {
        game->texte.couleur.r = 255;
        game->texte.couleur.g = 255;
        game->texte.couleur.b = 255;

        game->gui.pos_dialogue.x=(game->config.resolution_w-game->gui.dialogue[0]->w)/2;
        game->gui.pos_dialogue.y=90;

        game->gui.pos_btn.x=(game->config.resolution_w-game->gui.dialogue[0]->w)/2 + 900;
        game->gui.pos_btn.y=580;

        game->texte.position.x = (game->config.resolution_w-game->gui.dialogue[0]->w)/2+50;
        game->texte.position.y = 500;
        game->texte.i=0;

        game->texte=dialogue_lines(game->texte);
        game->texte.fix=1;

    }
    game->texte.texte = TTF_RenderText_Solid(game->texte.police, game->texte.dialogue[game->texte.i], game->texte.couleur);
    SDL_BlitSurface(game->texte.texte, NULL, game->screen, &game->texte.position);
    game->texte.texte = TTF_RenderText_Solid(game->texte.police, game->texte.dialogue[game->texte.i+1], game->texte.couleur);
    game->texte.position.y+=50;
    SDL_BlitSurface(game->texte.texte, NULL, game->screen, &game->texte.position);
    game->texte.position.y-=50;

    SDL_Flip(game->screen);

}

Texte dialogue_lines(Texte texte)
{
    int i=0,j=0, lines=0,n=0;
    char c=' ';
    rewind(texte.f);
    while (i!=texte.actuel)
    {
        while(c!='[')
        {
            c=fgetc(texte.f);
        }
        if (c=='[')
        {
            fscanf(texte.f,"%d]\n",&i);
            c=fgetc(texte.f);
        }
    }
    n=ftell(texte.f)-1;

    if (i==texte.actuel)
    {
        c=' ';
        while(c!='[')
        {
            c=fgetc(texte.f);
            if (c=='\n')
                lines++;
        }

    }
    //fprintf(stderr,"%d",n);
    fseek(texte.f,n,SEEK_SET);
    i=0;
    //lines/=2;
    while(j<lines/2)
    {
        strcpy(texte.aux," ");
        fscanf(texte.f,"%d\n",&texte.indice[j]);
        texte.indice[j+1]=texte.indice[j];

        fgets(texte.aux,100,texte.f);
        texte.aux[strlen(texte.aux+1)]='\0';
        strcpy(texte.dialogue[j],texte.aux);

        strcpy(texte.aux," ");
        fgets(texte.aux,100,texte.f);
        texte.aux[strlen(texte.aux+1)]='\0';
        strcpy(texte.dialogue[j+1],texte.aux);
        j+=2;
    }
    texte.line=lines;
    return (texte);
}


int SDL_TICKS_PASSED(unsigned int A, unsigned int B)
{
    return(SDL_GetTicks()-A>=B);
}


void load_music(GAME *game)
{
    char file[50]=" ";

    sprintf(file,"DATA/SFX/level%d.mp3",game->level);
    game->musique.ambient = Mix_LoadMUS(file);

}

void play_music(Music *musique)
{
    Mix_PlayMusic(musique->ambient, -1);
	Mix_VolumeMusic(MIX_MAX_VOLUME/5);
}

void free_memory(GAME *game)
{
    int i=0;

/*    for(i=0;i<5;i++)
        if (game->background.image[i]!=NULL)
            SDL_FreeSurface(game->background.image[i]);
*/
    SDL_FreeSurface(game->background.levelCollision);


    SDL_FreeSurface(game->character.image);
    SDL_FreeSurface(game->gui.avatar);
    SDL_FreeSurface(game->gui.hp);
    SDL_FreeSurface(game->gui.inventaire);

    for (i=0;i<2;i++)
    {
        //SDL_FreeSurface(game->gui.btn_animated[0]);
        SDL_FreeSurface(game->gui.btn_animated[i]);
    }


    for (i=0;i<2;i++)
    {
        if (game->gui.dialogue[i]!=NULL)
            SDL_FreeSurface(game->gui.dialogue[i]);
    }



	for (i=1;i<33;i++)
    {
        if (game->gui.died[i]!=NULL)
            SDL_FreeSurface(game->gui.died[i]);
    }




    for (i=0; i<5; i++)
        if (game->npc[i].image!=NULL)
            SDL_FreeSurface(game->npc[i].image);

     for (i=0; i<5; i++)
        if (game->objects.bullet[i].image!=NULL)
             SDL_FreeSurface(game->objects.bullet[i].image);

    Mix_FreeMusic(game->musique.ambient);

}

int center_camera(GAME *game)
{
    return (game->character.position.x+32>game->config.resolution_w/2 && game->character.position.x-32<game->config.resolution_w/2);
}

int random_case(GAME *game)
{
    return(((game->background.counter>20) && (game->background.counter <24)) || ((game->background.counter>25)&&(game->background.counter<29)) || ((game->background.counter>46) && (game->background.counter <50)) || ((game->background.counter>51)&&(game->background.counter<55)) || ((game->background.counter>56)&&(game->background.counter<60)) || ((game->background.counter>96)&&(game->background.counter<100)));
}

char *tostr(int x)
{
    char *ch=(char*)malloc(3*sizeof(char));
    sprintf(ch,"%d",x);
    return ch;
}

int relative_x(GAME *game, SDL_Rect position)
{
    return (position.x-game->background.scroll_x);
}


##### ./events.c #####
#include <unistd.h>  // For POSIX systems like Linux
#include <time.h>    // For timing functions
#include "game.h"

/**

* @file events.c

* @author C Squad

* @version 1.0

* @date May 14, 2016

*/

void load_next_level(GAME *game);
int save_level(GAME *game);
void teleport_next_door(GAME *game);
int pick_item(GAME *game);
void drop_item(GAME *game);
void reload_this_level(GAME *game);

int manage_events(GAME *game, SDL_Event *event)
{
    int continuer=1;

    if (SDL_PollEvent(event))
    {

        if ((*event).type==SDL_QUIT)
        {
            continuer=0;
        }

        else if ((*event).type==SDL_KEYDOWN)
        {
            switch((*event).key.keysym.sym)
            {
            case SDLK_RIGHT:
            {
                game->input.right=1;
                game->input.left=0;
            }
            break;

            case SDLK_LEFT:
            {
                game->input.left=1;
                game->input.right=0;
            }
            break;

            case SDLK_UP:
            {
                game->input.up=1;
            }
            break;

            case SDLK_e:
            {
                game->gui.show_inv=1;
            }
            break;



            case SDLK_RETURN:
            {
                game->input.enter=1;
                if (game->character.died)
                {
                    game->character.died=0;
                    game->global.fix_died=0;
                    game->background.scroll_x=game->global.checkpoint;
                    game->character.position.x=game->config.resolution_w/2;
                    if (game->character.life<0)
                        {
                            game->character.life=3;
                            game->global.checkpoint=0;
                        }

                }

            }
            break;

            case SDLK_SPACE:
                if (game->gui.show_dialogue)
                {
                    if(game->global.fix==1)
                    {
                        if (game->texte.i<game->texte.line-game->texte.line/2-2)
                            game->texte.i+=2;
                        else
                        {
                            game->gui.show_dialogue=0;
                        }
                        game->global.fix=2;
                    }
                }

                break;

            default:
                break;
            }
        }

        else if((*event).type==SDL_KEYUP)
            switch((*event).key.keysym.sym)
            {
            case SDLK_ESCAPE:
                if (game->global.stopDisplay==0)
                {
                    game->global.stopDisplay=1;
                    game->dialogue.interrupt = 1;
                    game->dialogue.saving_state = 1;
                }
                else
                {
                    game->global.stopDisplay=0;
                    game->dialogue.interrupt = 0;
                    game->dialogue.saving_state = 0;
                }

                break;

            case SDLK_RIGHT:
            {
                game->dialogue.saving_state = 2;
                game->input.right=0;
            }
            break;

            case SDLK_LEFT:
            {
                game->dialogue.saving_state = 1;
                game->input.left=0;
            }
            break;

            case SDLK_UP:
            {
                game->input.up=0;
            }
            break;

            case SDLK_e:
                game->gui.show_inv=0;
                break;


            case SDLK_SPACE:
                if (game->gui.show_dialogue)
                    game->global.fix=1;
                break;
            case SDLK_F10:
                load_next_level(game);
                break;
            case SDLK_r:
                reload_this_level(game);
                break;
            case SDLK_RETURN:
                if (game->dialogue.interrupt==1)
                {
                    if (game->dialogue.saving_state==1)
                    {
                        save_level(game);
                        continuer=0;
                    }
                    else
                        continuer=0;
                }

                if (game->global.EOL)
                    load_next_level(game);

                if (game->global.on_door)
                    teleport_next_door(game);

                if(pick_item(game)==0)
                    drop_item(game);



                break;

            case SDLK_f:
                game->background.scroll_x+=80;
                break;

            default:
                break;

            }

    }


    return continuer;
}


##### ./level.c #####
#include <unistd.h>
#include "game.h"
#include "functions.h"
#include "level.h"
#include <math.h>



/**

* @file level.c

* @brief contains the game loop

* @author C Squad

* @version 1.2

* @date May 20, 2016

**/

void level1 (GAME *game);
void display (GAME *game);


void loadLevel(GAME *game)
{
    load_music(game);
    init_level(game);

    SDL_FillRect(game->screen, NULL, SDL_MapRGB(game->screen->format, 0, 0, 0));
    play_music(&game->musique);
    game->global.animate=0;
}

void load_next_level(GAME *game)
{
    game->level++;
    game->global.stopDisplay=1;
    Mix_PauseMusic();
    game->global.stopDisplay=0;

    //free_memory(game);
    loadLevel(game);

}


void reload_this_level(GAME *game)
{
    game->global.stopDisplay=1;
    Mix_PauseMusic();
    game->global.stopDisplay=0;

    //free_memory(game);
    loadLevel(game);

}

void playLevel(GAME *game)
{
    int continuer = 1;
    SDL_Event event;

    unsigned int elapsed;
    unsigned int lasttime = SDL_GetTicks();

    load_menuQuit(game);
    loadLevel(game);

    game->global.stopDisplay = 0;

    while (continuer)
    {
        lasttime = SDL_GetTicks();

        if (!manage_events(game, &event))
            continuer = 0;

        if (!game->character.died)
        {
            if (game->level == 1)
                level1(game);
            else if (game->level == 2)
                level2(game);
            else if (game->level == 3)
                level3(game);
            else if (game->level == 4)
                level4(game);
        }

        display(game);

        if (game->global.FIN)
        {
            if (continuer)
            {
                if (Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 4, 1024) == -1)
                {
                    printf("[-] %s", Mix_GetError());
                }
                continuer = 0;
                Mix_PauseMusic();
                // play_video(game, "OUTRO.mpg") supprimé
            }
        }

        if (game->dialogue.interrupt)
            saving_menu(game, game->dialogue);

        if (game->level != 4)
        {
            if (collision_cercle(game->character.pos_cercle, game->objects.objective.cercle)) // Fin du niveau ici
            {
                game->global.EOL = 1;
                strcpy(game->texte.message, "Press Enter to advance");
                game->global.show_message = 1;
                game->texte.position.x = game->character.position.x + 50;
                game->texte.position.y = game->character.position.y - 40;
            }
            else
            {
                if (game->global.EOL)
                    game->global.show_message = 0;

                game->global.EOL = 0;
            }
        }

        elapsed = SDL_GetTicks() - lasttime;
        if (elapsed < 1000 / FPS)
            SDL_Delay(1000 / FPS - elapsed);
    }
    game->global.stopDisplay = 1;
    SDL_Delay(100);
    fclose(game->texte.f);
    TTF_CloseFont(game->texte.police);
}
void playTutorial (GAME *game)
{
    int i=0;

    for (i=1;i<9;i++)
    {
        SDL_BlitSurface(game->objects.tutorial[i],NULL,game->screen,&game->objects.pos_tuto);
        SDL_BlitSurface(game->objects.tutorial[0],NULL,game->screen,&game->objects.pos_tuto);
        SDL_Flip(game->screen);
        SDL_Delay(600);
    }

}
void level1 (GAME *game)
{
    if (!game->gui.show_dialogue && !game->gui.show_inv)
        movement(game);

    movement_npc(game, 0);
    movement_npc(game, 2);
    movement_npc(game, 3);

    if (onTexte(game)>0)    //collision pixel par pixel to check dialogue
    {
        game->character.look=4;
        game->character.actuel=0;
        if(!game->global.fix)
        {
            game->texte.actuel=onTexte(game);
            if (game->texte.actuel==1)
                game->npc[1].actuel=1;
            game->gui.show_dialogue=1;
            game->global.fix=1;
        }
    }
    else
    {
        game->npc[1].actuel=0;
        game->global.fix=0;
        game->texte.fix=0;
        game->gui.show_dialogue=0;
        game->texte.i=0;
    }

   if (TRUE_X>3500)
        game->global.checkpoint=3500;
    else if (TRUE_X>1200)
        game->global.checkpoint=1200;


}


void level2 (GAME *game)
{
    int i=0;

    if (!game->gui.show_dialogue && !game->gui.show_inv)
    {
        movement(game);
        if (TRUE_X>8180)
        {
            if (game->objects.inventory.item[2].have==0 || game->objects.inventory.item[3].have==0)
                game->background.scroll_x-=SPEED;
        }
    }


    for (i=0; i<5; i++)
    {
        if (collision_cercle(game->character.pos_cercle,game->objects.door[i]))
        {
            sprintf(game->texte.message,"Press Enter");
            game->global.on_door=1;
            game->global.show_message=1;
            game->texte.position.x=game->character.position.x + 30;
            game->texte.position.y=game->character.position.y - 40;
            break;
        }
        else
        {
            if (game->global.on_door)
            {
                game->global.on_door=0;
                game->global.show_message=0;
            }
        }
    }


    if (onTexte(game)>0)    //collision pixel par pixel to check dialogue
    {
        if (game->input.enter)
        {

            if(!game->global.fix)
            {
                game->texte.actuel=onTexte(game);
                game->gui.show_dialogue=1;
                game->global.fix=1;
            }
        }
        else
        {
            sprintf(game->texte.message,"Press Enter");
            game->global.on_door=1;
            game->global.show_message=1;
            game->texte.position.x=game->character.position.x + 30;
            game->texte.position.y=game->character.position.y - 40;
        }
    }
    else
    {
        game->global.fix=0;

        game->gui.show_dialogue=0;
        game->texte.fix=0;
        game->texte.i=0;
        game->input.enter=0;
    }




    if (game->global.level2_show_items)
    {
        for (i=2; i<4; i++)
            if (collision_cercle(game->character.pos_cercle, game->objects.inventory.item[i].cercle))
                if (game->objects.inventory.item[i].have==0)
                {
                    sprintf(game->texte.message,"Press Enter");
                    game->global.on_door=1;
                    game->global.show_message=1;
                    game->texte.position.x=game->character.position.x + 30;
                    game->texte.position.y=game->character.position.y - 40;
                }

        if (collision_color(game)==GREEN)
        {

            sprintf(game->texte.message,"Press Enter");
            game->global.green_item=1;
            game->global.show_message=1;
            game->texte.position.x=game->character.position.x + 30;
            game->texte.position.y=game->character.position.y - 40;

        }
            else if (game->global.green_item)
            {
                game->global.blue_item=0;
                game->global.show_message=0;
                game->global.green_item=0;
            }


    }
    else if (game->background.scroll_x>7000)
        game->global.level2_show_items=1;


}

void level3 (GAME *game)
{
    int i=0;
    if (!game->gui.show_inv)
        movement_level3(game);



    for (i=0; i<11; i++)
    {
        if (collision_cercle(game->character.pos_cercle,game->objects.door[i]))
        {
            sprintf(game->texte.message,"Press Enter");
            game->global.on_door=1;
            game->global.show_message=1;
            game->texte.position.x=game->character.position.x + 30;
            game->texte.position.y=game->character.position.y - 40;
            break;
        }
        else
        {
            if (game->global.on_door)
            {
                game->global.on_door=0;

                game->global.show_message=0;
            }
        }

    }


    if (collision_cercle(game->character.pos_cercle, game->objects.inventory.item[1].cercle))
        if (game->objects.inventory.item[1].have==0)
        {
            sprintf(game->texte.message,"Press Enter");
            game->global.on_door=1;
            game->global.show_message=1;
            game->texte.position.x=game->character.position.x + 30;
            game->texte.position.y=game->character.position.y - 40;
        }


    SDL_Delay(2);
}

void level4 (GAME *game)
{
    if (game->character.position.x < 150 || collision_fall(game))
    {
        SDL_FillRect(game->screen, NULL, SDL_MapRGB(game->screen->format, 0, 0, 0));

        loading_screen(game);
        game->character.life--;
        game->background.scroll_x=0;
        game->character.position.x=game->config.resolution_w/2;
    }

    if (collision_cercle(game->character.pos_cercle, game->objects.objective.cercle))
    {
        SDL_Delay(300);
        game->global.FIN=1;
    }

    if (!game->global.FIN)
    {

        if (game->background.scroll_x<8600)
        {
            game->input.right=1;
            mouvement_level4(game);
            game->input.right=0;
        }
        else
        {
            //movement(game);
            game->input.right=1;
            mouvement_level4(game);
            game->input.right=0;
            SDL_Delay(15);
        }


    }

}


void teleport_next_door(GAME *game)
{
    int i=0;
    if (game->level==2)
    {
        for (i=0; i<5; i++)
        {
            if (collision_cercle(game->character.pos_cercle,game->objects.door[i]))
            {
                if (TRUE_X<=game->objects.door[i].x)
                {
                    game->character.position.x=50;
                    if (game->background.scroll_x+2*game->config.resolution_w<game->background.image[0]->w)
                        game->background.scroll_x+=game->config.resolution_w;
                    else
                    {
                        game->background.scroll_x=game->background.image[0]->w-game->config.resolution_w;
                        game->character.position.x+=200;
                    }
                }
                else
                {
                    game->character.position.x=game->config.resolution_w-100;
                    game->background.scroll_x-=game->config.resolution_w;

                }
            }
        }
    }
    else if (game->level==3)
    {
        for (i=0; i<11; i++)
        {
            if (collision_cercle(game->character.pos_cercle,game->objects.door[i]))
            {
                switch(i)
                {
                case 0:
                    game->background.scroll_x=6240-22;
                    game->character.position.x=game->objects.door[1].x-game->background.scroll_x;
                    break;
                case 1:
                    game->background.scroll_x=3265-22;
                    game->character.position.x=game->objects.door[7].x-game->background.scroll_x;
                    break;
                case 2:
                    game->background.scroll_x=4765-22;
                    game->character.position.x=game->objects.door[3].x-game->background.scroll_x;
                    break;
                case 3:
                    game->background.scroll_x=4765-22;
                    game->character.position.x=game->objects.door[5].x-game->background.scroll_x;
                    break;
                case 4:
                    game->background.scroll_x=3265-22;
                    game->character.position.x=game->objects.door[6].x-game->background.scroll_x;
                    break;
                case 5:
                    game->background.scroll_x=1780-22;
                    game->character.position.x=game->objects.door[9].x-game->background.scroll_x;
                    break;
                case 6:
                    game->background.scroll_x=6240-22;
                    game->character.position.x=game->objects.door[1].x-game->background.scroll_x;
                    break;
                case 7:
                    game->background.scroll_x=6240-22;
                    game->character.position.x=game->objects.door[2].x-game->background.scroll_x;
                    break;
                case 8:////
                    game->background.scroll_x=242-22;
                    game->character.position.x=game->config.resolution_w/2;
                    break;
                case 9:
                    game->background.scroll_x=6240-22;
                    game->character.position.x=game->objects.door[1].x-game->background.scroll_x;
                    break;
                }
            }
        }
    }
}


void display(GAME *game)
{
    if (!game->global.stopDisplay)
    {
        game->background.counter++;
        if (game->background.counter>100)
            game->background.counter=0;//rand()%100;

        getPositions(game);
        update_screen(game);

    }
}




##### ./display.h #####
#ifndef DISPLAY_H_INCLUDED
#define DISPLAY_H_INCLUDED

void blit_bullet(GAME *game);
int update_display (void *data);
void getPositions(GAME *game);
void update_screen(GAME *game);
void BlitNPC(GAME *game);
int random_case(GAME *game);
void blit_text(GAME *game);
void show_message(GAME *game);


#endif // DISPLAY_H_INCLUDED


##### ./items.c #####
#include "game.h"
#include "level.h"  // Add this to include the declaration of collision_cercle

/**
 * @file items.c
 * @author C Squad
 * @version 1.0
 * @date May 14, 2016
 */

void inventory_options(GAME *game);
int fix_inv = 0;

void init_items(GAME *game)
{
    int i = 0;
    char item[40] = " ";
    game->objects.inventory.count = 0;
    for (i = 0; i < MAX_ITEMS; i++)
    {
        game->objects.inventory.item[i].number = 0;
        game->objects.inventory.item[i].have = 0;
        game->objects.inventory.item[i].disposable = 0;
        game->objects.inventory.item[i].position.x = 0;
        game->objects.inventory.item[i].position.y = 0;
        sprintf(item, "DATA/GFX/inventory/item%d.png", i);
        game->objects.inventory.item[i].image = IMG_Load(item);
        sprintf(item, "DATA/GFX/inventory/description%d.png", i);
        game->objects.inventory.item[i].description = IMG_Load(item);
    }
}

int pick_item(GAME *game)
{
    int i = 0;
    for (i = 0; i < MAX_ITEMS; i++)
    {
        if (collision_cercle(game->character.pos_cercle, game->objects.inventory.item[i].cercle))
        {
            if (game->objects.inventory.item[i].have == 0)
            {
                if (game->objects.inventory.item[i].disposable)
                {
                    // game->objects.inventory.item[i].number=0;//game->objects.inventory.count;
                    game->objects.inventory.count++;
                    game->objects.inventory.item[i].have = 1;
                    game->objects.inventory.item[i].selected = 0;
                    return 1;
                }
            }
        }
    }
    return 0;
}

void drop_item(GAME *game)
{
    int i = 0;
    for (i = 0; i < MAX_ITEMS; i++)
    {
        if (game->objects.inventory.item[i].have == 1)
        {
            if (game->objects.inventory.item[i].selected)
            {
                if (game->objects.inventory.item[i].disposable)
                {
                    game->objects.inventory.item[i].cercle.x = TRUE_X; // +game->character.direction*50;
                    game->objects.inventory.item[i].have = 0;
                    game->objects.inventory.item[i].selected = 0;
                }
            }
        }
    }
}

void show_inventory(GAME *game)
{
    int i = 0;

    game->gui.pos_inv.x = game->character.position.x + 30;
    game->gui.pos_inv.y = game->character.position.y - 90;

    SDL_BlitSurface(game->gui.inventaire, NULL, game->screen, &game->gui.pos_inv);

    for (i = 0; i < MAX_ITEMS; i++)
    {
        if (game->objects.inventory.item[i].have == 1)
        {
            game->objects.inventory.item[i].position.y = game->gui.pos_inv.y + 5;
            game->objects.inventory.item[i].position.x = game->gui.pos_inv.x + game->objects.inventory.item[i].number * 42 + 6 + game->objects.inventory.item[i].number * 5;
            SDL_BlitSurface(game->objects.inventory.item[i].image, NULL, game->screen, &game->objects.inventory.item[i].position);
            if (game->objects.inventory.item[i].selected == 1)
            {
                // game->objects.inventory.item[i].position.x+=game->objects.inventory.item[i].number*5;
                SDL_BlitSurface(game->gui.frame, NULL, game->screen, &game->objects.inventory.item[i].position);
                game->objects.inventory.item[i].position.y = game->gui.pos_inv.y - game->objects.inventory.item[i].description->h - 20;
                game->objects.inventory.item[i].position.x = game->gui.pos_inv.x;
                SDL_BlitSurface(game->objects.inventory.item[i].description, NULL, game->screen, &game->objects.inventory.item[i].position);
            }
        }
    }
    if (game->level == 3)
        game->objects.inventory.item[0].selected = 1;
    inventory_options(game);
}

void inventory_options(GAME *game)
{
    int i = 0;

    if (game->input.right && !fix_inv)
    {
        fix_inv = 1;
        for (i = 0; i < MAX_ITEMS - 1; i++)
        {
            if (game->objects.inventory.item[i].selected)
            {
                game->objects.inventory.item[i].selected = 0;
                game->objects.inventory.item[i + 1].selected = 1;
                break;
            }
        }
    }

    if (game->input.left && !fix_inv)
    {
        for (i = 1; i < MAX_ITEMS; i++)
        {
            if (game->objects.inventory.item[i].selected)
            {
                game->objects.inventory.item[i].selected = 0;
                game->objects.inventory.item[i - 1].selected = 1;
                break;
            }
        }
    }

    if (game->input.right == 0 && game->input.left == 0)
        fix_inv = 0;
}


##### ./bullet.h #####
#ifndef BULLET_H_INCLUDED
#define BULLET_H_INCLUDED
#include "game.h"

typedef struct Bullet
{
	SDL_Surface *image;
	SDL_Rect  position, relativePos;
	Cercle cercle;
	int speed, started, direction, moving;
	unsigned int ticks, elapsed;
}Bullet;




#endif // BULLET_H_INCLUDED


##### ./main.c #####
#include "game.h"
#include "functions.h"  // intro.h supprimé
#include "level.h"

/**
 * @file main.c
 * @brief It never ends main.
 * @author C Squad
 * @version 1.0
 * @date May 14, 2016
 */

int game_menu(GAME *game);
int get_config(GAME *game);

int main(int argc, char *argv[]) {
    GAME game = {0}; // Initialisation à zéro pour éviter un comportement indéfini

    // Initialisation des sous-systèmes SDL
    if (SDL_Init(SDL_INIT_VIDEO) < 0) {
        fprintf(stderr, "SDL_Init failed: %s\n", SDL_GetError());
        return EXIT_FAILURE;
    }

    // Définition du titre et de l'icône de la fenêtre
    SDL_WM_SetCaption("It never ends", NULL);
    SDL_Surface *icon = IMG_Load("DATA/GFX/GUI/Loupe.png");
    if (!icon) {
        fprintf(stderr, "Failed to load icon: %s\n", IMG_GetError());
    } else {
        SDL_WM_SetIcon(icon, NULL);
        SDL_FreeSurface(icon); // Libération de la surface après utilisation
    }

    // Chargement de la configuration ou utilisation des valeurs par défaut
    if (get_config(&game) == 0) {
        if (game.config.fullscreen == 1) {
            game.screen = SDL_SetVideoMode(game.config.resolution_w, game.config.resolution_h, 32,
                                           SDL_DOUBLEBUF | SDL_HWSURFACE | SDL_FULLSCREEN);
        } else {
            game.screen = SDL_SetVideoMode(game.config.resolution_w, game.config.resolution_h, 32,
                                           SDL_DOUBLEBUF | SDL_HWSURFACE);
        }
    } else {
        // Configuration par défaut si le fichier de config est absent
        game.screen = SDL_SetVideoMode(1280, 720, 32, SDL_DOUBLEBUF | SDL_HWSURFACE);
    }

    // Vérification de l'initialisation de l'écran
    if (!game.screen) {
        fprintf(stderr, "SDL_SetVideoMode failed: %s\n", SDL_GetError());
        SDL_Quit();
        return EXIT_FAILURE;
    }

    // Initialisation de TTF et SDL_Mixer
    if (TTF_Init() < 0) {
        fprintf(stderr, "TTF_Init failed: %s\n", TTF_GetError());
        SDL_Quit();
        return EXIT_FAILURE;
    }

    if (Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 1024) == -1) {
        fprintf(stderr, "Mix_OpenAudio failed: %s\n", Mix_GetError());
        TTF_Quit();
        SDL_Quit();
        return EXIT_FAILURE;
    }

    // L'appel à intro(&game) est supprimé

    // Affichage de l'écran de chargement
    loading_screen(&game);

    // Démarrage du menu du jeu
    start_menu(&game);

    // Nettoyage des ressources
    SDL_FreeSurface(game.screen);
    TTF_Quit();
    Mix_CloseAudio();
    SDL_Quit();

    return EXIT_SUCCESS;
}

int get_config(GAME *game) {
    game->config.f = fopen("config/config.cfg", "r");
    if (game->config.f != NULL) {
        fscanf(game->config.f, "[resolution]\n");
        fscanf(game->config.f, "w=%d\n", &game->config.resolution_w);
        fscanf(game->config.f, "h=%d\n", &game->config.resolution_h);
        fscanf(game->config.f, "fullscreen=%d\n", &game->config.fullscreen);
        fclose(game->config.f); // Fermeture du fichier après lecture
        return 0;
    } else {
        return -1; // Retourne -1 si le fichier est absent
    }
}

void start_menu(GAME *game) {
    if (game_menu(game) == 0) {
        playLevel(game);
    }
}


##### ./functions.h #####
#ifndef FONCTIONS_H_INCLUDED
#define FONCTIONS_H_INCLUDED
#include "game.h"
#include "bullet.h"

int relative_x(GAME *game, SDL_Rect position);
char *tostr(int x);
int random_case(GAME *game);
int center_camera(GAME *game);
void free_memory(GAME *game);
int SDL_TICKS_PASSED(unsigned int A, unsigned int B);
void loading_screen(GAME *game);
void blit_text(GAME *game);
Texte dialogue_lines(Texte texte);
void load_music(GAME *game);
void init_level(GAME *game);
// void play_video(GAME *game, char filename[30]); supprimé
Color collision_color(GAME *game);

void init_bullet(GAME *game, int a, int b);
void blit_bullet(GAME *game);
void bullet_shot(GAME *game, int a);

void load_menuQuit(GAME *game);

void show_inventory(GAME *game);

void start_menu(GAME *game);

#endif // FONCTIONS_H_INCLUDED


##### ./mouvement.c #####
#include "game.h"
#include "functions.h"
#include "level.h"
#include "collision.h"

/**

* @file mouvement.c

* @brief It never ends

* @author C Squad

* @version 1.0

* @date May 14, 2016

* player movement and camera management.

*/

int center_camera(GAME *game);
void update_screen(GAME *game);
int Collision_PPP(GAME *game, Character perso);





int borders_test(GAME *game)
{
    printf("a");
    int j = 0;

    if (game->input.right || game->arduino.right)
    {
        while (game->objects.borders.left[j] != -1)
        {
            if (TRUE_X > game->objects.borders.left[j] && TRUE_X < game->objects.borders.right[j])
                return (game->background.scroll_x + game->config.resolution_w > game->objects.borders.right[j]);
            else
                j++;
        }
        return 0;  // Add this return for when the while loop exits
    }
    return 0;  // Add this return for when the if condition is false
}

void movement(GAME *game)
{
        /* Right */

        if ((game->input.right || game->arduino.right) && !Collision_PPP(game,game->character))
        {
            game->background.scroll_x+=SPEED;
            if (borders_test(game))//game->background.scroll_x > game->background.image[0]->w-game->config.resolution_w)
            {
                game->background.scroll_x-=SPEED;
                game->character.position.x+=SPEED;
                if (game->character.position.x>game->config.resolution_w-game->character.position.w)
                    game->character.position.x-=SPEED;
            }

            if (!center_camera(game))
            {
                if (game->character.position.x<game->config.resolution_w/2)
                {
                    game->character.position.x+=SPEED;
                    game->background.scroll_x-=SPEED;
                }
            }


            if (game->character.look>5)
            {
                game->character.look=0;
                game->character.actuel=0;
            }

            game->character.actuel++;
            if (game->character.actuel>5)
            {
                game->character.actuel=0;
                game->character.look++;
            }
            if (game->character.look>3)
                game->character.look=0;

            game->global.movement=0;
        }

        /* Left */

        else if ((game->input.left || game->arduino.left) && !Collision_PPP(game,game->character))
        {
            game->background.scroll_x-=SPEED;
            if (game->background.scroll_x<0)
            {
                game->background.scroll_x+=SPEED;
                game->character.position.x-=SPEED;
                if (game->character.position.x<0)
                    game->character.position.x+=SPEED;
            }

            if (!center_camera(game))
            {
                if (game->character.position.x>game->config.resolution_w/2)
                {
                    game->character.position.x-=SPEED;
                    game->background.scroll_x+=SPEED;
                }
            }
            if (game->character.look<5)
            {
                game->character.look=5;
                game->character.actuel=5;
            }

            game->character.actuel--;
            if (game->character.actuel<1)
            {
                game->character.actuel=5;
                game->character.look++;
            }
            if (game->character.look>8)
                game->character.look=4;


            game->global.movement=1;

        }

        else// if (!collision_pente(game))
        {
            if (game->global.movement==0)
            {
                game->character.look=4;
                game->character.actuel=0;
            }
            else
            {
                game->character.look=9;
                game->character.actuel=5;
            }
        }

        if ((game->input.up || game->arduino.up) && !game->input.fix)
        {
            game->input.startJump = 1;
        }

        /* JUMP START */

        if (game->input.startJump)
        {
            game->input.fix=1;

            if (game->input.jumpHeight < maxJmpH)
            {
                game->input.jumpHeight += JUMP_POWER;
                game->character.position.y -= JUMP_POWER + 2*GRAVITY;
            }
            else
            {
                game->input.startJump=0;
                game->input.jumpHeight=0;
            }
        }

        /* JUMP END */



        /* GRAVITY */
        game->character.position.y+=GRAVITY;

        if (onGround(game, game->character))
        {
            game->character.position.y-=GRAVITY;
            game->input.fix=0;
        }

        game->character.position.y+=GRAVITY;

        if (onGround(game, game->character))
        {
            game->character.position.y-=GRAVITY;
            game->input.fix=0;
        }



    game->character.pos_cercle.x=game->character.position.x+game->background.scroll_x;
    game->character.pos_cercle.y=game->character.position.y+40;
    game->character.pos_cercle.r=30;

}


void mouvement_level4(GAME *game)
{
    int JMP_POWER=16;

    if (!Collision_PPP(game,game->character))
    {
        game->background.scroll_x+=SPEED;
        if (game->background.scroll_x>10000-game->config.resolution_w)
        {
            game->background.scroll_x-=SPEED;
            game->character.position.x+=SPEED;
        }
    }

    else
    {
        game->background.scroll_x+=SPEED;
        game->character.position.x-=SPEED;
    }


            if (game->character.look>5)
            {
                game->character.look=0;
                game->character.actuel=0;
            }

            game->character.actuel++;
            if (game->character.actuel>5)
            {
                game->character.actuel=0;
                game->character.look++;
            }
            if (game->character.look>3)
                game->character.look=0;

        /* JUMP START */

        if (game->input.up && !game->input.fix)
        {
            game->input.startJump = 1;
        }

        if (game->input.startJump)
        {
            game->input.fix=1;

            if (game->input.jumpHeight < 160) //MAX_JmpH
            {
                game->input.jumpHeight += JMP_POWER; //var
                game->character.position.y -= JMP_POWER + 2*GRAVITY;
            }
            else
            {
                game->input.startJump=0;
                game->input.jumpHeight=0;
            }
        }

        /* JUMP END */



        /* GRAVITY */
        game->character.position.y+=GRAVITY;

        if (onGround(game, game->character))
        {
            game->character.position.y-=GRAVITY;
            game->input.fix=0;
        }

        game->character.position.y+=GRAVITY;

        if (onGround(game, game->character))
        {
            game->character.position.y-=GRAVITY;
            game->input.fix=0;
        }

    if (collision_pente(game) && game->input.right)
        {
            game->character.position.y-=5;
            //game->character.position.x+=SPEED;
        }


game->character.pos_cercle.x=TRUE_X;
game->character.pos_cercle.y=game->character.position.y+game->character.position.h/2;
}


void movement_level3(GAME *game)
{
	if (game->background.scroll_x>7600)
	{
        if (game->input.right && !Collision_PPP(game,game->character))
        {
            game->background.scroll_x+=SPEED;
            if (borders_test(game))
            {
                game->background.scroll_x-=SPEED;
                game->character.position.x+=SPEED;
                if (game->character.position.x>game->config.resolution_w-game->character.position.w)
                    game->character.position.x-=SPEED;
            }

            if (!center_camera(game))
            {
                if (game->character.position.x<game->config.resolution_w/2)
                {
                    game->character.position.x+=SPEED;
                    game->background.scroll_x-=SPEED;
                }
            }


            if (game->character.look>5)
            {
                game->character.look=0;
                game->character.actuel=0;
            }

            game->character.actuel++;
            if (game->character.actuel>5)
            {
                game->character.actuel=0;
                game->character.look++;
            }
            if (game->character.look>3)
                game->character.look=0;

            game->global.movement=0;
        }

        /* ------------------------------------------------------ */

        else if (game->input.left && !Collision_PPP(game,game->character))
        {
            game->background.scroll_x-=SPEED;
            if (game->background.scroll_x<0)
            {
                game->background.scroll_x+=SPEED;
                game->character.position.x-=SPEED;
                if (game->character.position.x<0)
                    game->character.position.x+=SPEED;
            }

            if (!center_camera(game))
            {
                if (game->character.position.x>game->config.resolution_w/2)
                {
                    game->character.position.x-=SPEED;
                    game->background.scroll_x+=SPEED;
                }
            }
            if (game->character.look<5)
            {
                game->character.look=5;
                game->character.actuel=5;
            }

            game->character.actuel--;
            if (game->character.actuel<1)
            {
                game->character.actuel=5;
                game->character.look++;
            }
            if (game->character.look>8)
                game->character.look=4;


            game->global.movement=1;

        }

        else// if (!collision_pente(game))
        {
            if (game->global.movement==0)
            {
                game->character.look=4;
                game->character.actuel=0;
            }
            else
            {
                game->character.look=9;
                game->character.actuel=5;
            }
        }

	}

	else
	{

if (game->input.right && !Collision_PPP(game,game->character))
        {

            game->character.position.x+=SPEED;

            if (game->character.look>5)
            {
                game->character.look=0;
                game->character.actuel=0;
            }

            game->character.actuel++;
            if (game->character.actuel>5)
            {
                game->character.actuel=0;
                game->character.look++;
            }
            if (game->character.look>3)
                game->character.look=0;

            game->global.movement=0;
        }

        /* ------------------------------------------------------ */

        else if (game->input.left && !Collision_PPP(game,game->character))
         {
			 game->character.position.x-=SPEED;


            if (game->character.look<5)
            {
                game->character.look=5;
                game->character.actuel=5;
            }

            game->character.actuel--;
            if (game->character.actuel<1)
            {
                game->character.actuel=5;
                game->character.look++;
            }
            if (game->character.look>8)
                game->character.look=4;


            game->global.movement=1;

        }

        else
        {
            if (game->global.movement==0)
            {
                game->character.look=4;
                game->character.actuel=0;
            }
            else
            {
                game->character.look=9;
                game->character.actuel=5;
            }
        }
	}

        /* GRAVITY */
        game->character.position.y+=GRAVITY;

        if (onGround(game, game->character))
        {
            game->character.position.y-=GRAVITY;
            game->input.fix=0;
        }



    game->character.pos_cercle.x=game->character.position.x+game->background.scroll_x;
    game->character.pos_cercle.y=game->character.position.y+40;
    game->character.pos_cercle.r=30;

}



##### ./collision.h #####
#ifndef COLLISIONS_H
#define COLLISIONS_H


#include "game.h"

struct GAME;        // Forward declaration
struct Character;

extern int collision_fall(struct GAME *game);
extern int onGround(struct GAME *game, struct Character perso);
extern int collision_pente(struct GAME *game);
extern int Collision_PPP(struct GAME *game, struct Character perso);

typedef struct 
{
int x,y;
int h,w;
}Box;


typedef struct 
{
int x,y;
int r;
}Cercle;



#endif // COLLISIONS_H
